<html>
<head><title>Reiser4 libreiserfs Architecture Document.</title></head>
<body>

<table width=70%><tr><td align=center>
<h1>Reiser4 libreiserfs Architercure Document.</h1>
<h3>24 May 2002</h2>
</td></tr></table>

<h2>Introduction</h2>
<table width=70%><tr><td align=justify>
This document consists of two parts. First part describes DAL as the way of communication 
with any device through unified interface.  Second  part describes libreiserfs that works 
over DAL.
</td></tr></table>

<h2>DAL (Device Abstraction Layer)</h2>
<table width=70%><tr><td align=justify>
DAL is a layer between the device abstract object in "master" software package that uses
libreiserfs and libreiserfs. DAL layer handles all I/O requests from libreiserfs to that 
device.
</td></tr></table>

<h3>Abstract</h3>

<table width=70%><tr><td align=justify>
Following is not complete list of projects that are interested in using libreiserfs:<br>
GNU Parted, EVMS, GNU GRUB, Yaboot, Partimage, Reiserfsprogs.<br><br>

<i>Why additional abstraction layer is required in libreiserfs
	in order to cooperate with these packages?</i><br><br>

All these projects have their own abstract device that has 
additional properties except being plain UNIX block device.  

For example: various "policies", backing up, checking,  logging, 
etc. Some of these device abstract objects doesn't have opened file
descriptor (for real device) corresponding to them at all. For 
example, GNU GRUB or Yaboot are boot loaders and as such
do not and can not use standard C library and kernel services.<br><br>

Therefore  we  must export some "device-presentation independent" 
interface for all I/O operations. This  interface will be based 
on installable callback functions for every atomic I/O operation: 
to read from device, to write to device, to sync a device, to compare 
two devices, to obtain capacity	of device (number of bytes that can 
be stored on device) and to obtain flags device was opened with (read
only, read/write, etc).<br><br>

<i>Why should we burden ourselves with this?</i><br><br>

This is because we want to build our library (libreiserfs) on
an stable interface.  We have to rely on it.  However  I/O
requirements vary from one project to another.  Or doesn't
exist at all.<br>

In fact we are forcing all projects to use our DAL interface.  
Every  project implements our interface in order to be 
compatible with us.<br><br>

So, as every software package from listed above has unique 
(in theory) device nature, it must have also own device-nature-specific 
I/O working functions implemented in it. This I/O working 
functions will be very vary from one project to another. For 
example, reiserfsprogs will be using just "read", "write", 
"stat" for file descriptor, GNU Parted will be using "ped_geometry_read", 
"ped_geometry_write" functions for PedGeometry object and 
GNU GRUB will be using "biosdisk" function that is call to 
int 0x13 interrupt in fact.<br><br>

The  reiserfsprogs DAL object will be the simplest of them
all, since reiserfsprogs operates directly on a UNIX block
device (e.g., /dev/hda1), the reiserfsprogs implementation
of the abstract DAL operations  will  be  just  the  usual
read(),  write(),  and fsync() that operate on a UNIX file
descriptor.<br><br>

The GNU Parted DAL object will be a bit more complex.  One
reason that Parted requires a more sophisticated DAL is
that it has, roughly speaking,  more  complex device
abstract object. Parted  is able to check for errors and
to abort current action if anything went wrong. Due to this 
more complex behavior, libreiserfs cannot operate directly
on a block device and file descriptor. Another feature  of
Parted is its support for partition "slices", which are
sub-partitions of a  single  block  device  (supported  on
FreeBSD, for example).<br><br>

The GNU GRUB system is a bootloader, so it runs without
any kernel to support it. Therefore there must be a layer
of abstraction between libreiserfs and the client programs
that use it. Reiserfsprogs is a simple example that would
not require any DAL support, but support for a wider range
of libreiserfs applications will require a DAL layer to
interface with them.<br><br>

So every project  that  is going to use libreiserfs should
prepare "dal_ops" structure and fill it by its device 
specific I/O working functions. This "dal_ops" structure
is the central component of DAL. To use DAL object for I/O 
operations, libreiserfs will call installed in "dal_ops" 
callback functions for every "read", "write", etc operation
every time as it will be needed to read, write something.<br><br>

That is, all real I/O work is delegated to the appropriate
callback function. For example,  reiserfsck_read is be called 
for reiserfsck. reiserfsck_read calls  standard read(2) 
function to read from supplied file descriptor.<br><br>

For GNU Parted, ped_geometry_read callback function calls 
standard read(2) function, and for GNU GRUB, read callback 
calls "biosdisk" function.<br>

Actually "ped_geometry_read" calls "ped_device_read" function.
"ped_device_read" function calls "read" operation from current
architecture's device operation descriptor. This "read" operation
is callback function in fact and may operate on file descriptor
of device (drive) (/dev/hda, /dev/hdb, etc).<br><br>

For example, "dal_ops" for GNU GRUB looks roughly like this:<br><br>

For example, this stuff lies in separate device.S file. Function "biosdisk" 
does all work on device.
</td></tr></table>
	
<table width=70%><tr><td align=justify>
	
<pre>
ENTRY(biosdsik)
	...

	int $0x13

	...

	ret
</pre><br>

This stuff lies in DAL implementation for GNU GRUB. Let it be 
bios_dal.c.<br>

<pre>
extern int biosdisk(some_parameters);

int bios_read(some_parameters) {
	return biosdisk(some_parameters);
}

int bios_write(some_parameters) {
	return biosdisk(some_parameters);
}

struct bios_dal_ops bios_ops {
	read: bios_read,
	write: bios_write,
	...
}
</pre><br>

And after bios_dal_ops is ready, we will create dal_t that will 
contain bios_dal_ops in it.<br>

<pre>
dal_t *bios_dal_open(some_parameters) {

	return dal_open(bios_ops, some_parameters);
}
</pre><br>

On other hand, reiserfsprogs will prepare  "file_dal_ops".
It will roughly look:<br>

<pre>
int file_read(some_parameters) {
	return read(some_parameters);
}

int file_write(some_parameters) {
	return write
}

struct file_dal_ops file_ops {
	read: file_read,
	write: file_write,
	...
}

dal_t *file_dal_open(some_parameters) {
	return dal_open(file_ops, some_parameters);
}
</pre><br>

As  you  can see these two DALs have very different nature
and implementation.

Now lets show on Parted example, what happens when user 
issues command to resize partition with reiserfs on it. 
First of all we are interested in tracking of I/O operations.<br>

<ul>
<li>At user's request to resize partition, parted's parted-libreiserfs 
glue code creates an instance of "parted_dal" with installed 
into it own callback I/O operations, opens filesystem on it by 
"reiserfs_fs_open" and requests libreiserfs to perform filesystem 
resizing on passed "parted_dal".<br><br>

<li>At Parted's request, libreiserfs resizes given filesystem on 
given device (parted_dal) and for every I/O operation during resizing, 
libreiserfs calls I/O handlers from "parted_dal".<br><br>

<ul><li>In this stage execution control flows beetwen Parted and 
libreiserfs. Parted's I/O handlers do all I/O work (as usual 
reading or writing a block) and returns result to libreiserfs. 
libreiserfs continue working and again calls Parted's I/O handlers 
for reading, writing, etc.<br><br>
</ul>

<li>After libreiserfs finished resizing, it returns result of 
operation to Parted.
</ul>

Therefore DAL is just simple and stable interface. I has been called 
it as "stable", because it remains unchanged from one project to another.
</td></tr></table>

<h3>Implementation.</h3>

<table width=70%><tr><td align=justify>
Following is complete list of I/O operations that have  to be implemented 
by any DAL implementation.  Notice that not all of them have to do real 
work. For example, "stat" call is  only  required  just  for  proper stating 
of files and directories.  If "stat" not implemented, then stat  struct
(filled  by reiserfs_object_stat) will not contain a valid st_dev field.<br>

<pre>
struct dal_ops {
	int (*read)(dal_t *, void *, blk_t, count_t);
	int (*write)(dal_t *, void *, blk_t, count_t);
	int (*sync)(dal_t *);
	int (*flags)(dal_t *);
	int (*equals)(dal_t *, dal_t *);
	int (*stat)(dal_t *, struct stat *);
	blk_t (*len)(dal_t *);
	char *(*error) (dal_t *);
};
</pre><br>

<b>int (*read) (dal_t *dal, void *buff, blk_t block, count_t count)</b>

<p>
Reads  count  of  blocks  into given buffer, starting from given block. 
Returns true on success,  false  on  failure. Used by reiserfs_block_read 
function  for  reading from device.<br><br>

<b>int (*write) (dal_t *dal, void *buff, blk_t block, count_t count)</b>

<p>
Writes count of blocks from given buffer onto device, starting from given 
block. Returns true on success, false on failure. Used by reiserfs_block_write 
function for writing data to device.<br><br>

<b>int (*sync) (dal_t *dal)</b>

<p>
Syncs given device. Returns result. Used by front-ends for syncing device 
before it will be closed.<br><br>

<b>int (*flags) (dal_t *dal)</b>

<p>
Returns the flags for pointed device. For example, O_RDWR, O_LARGEFILE,
etc. Used, for example, by reiserfs_fs_open.<br><br>

<b>int (*equals) (dal_t *dal1, dal_t *dal2)</b>

<p>
Returns the result of comparing of dal1 and dal2. Widely used for determining
whether given DALs are equal.<br><br>

Imagine, mkfs program is calling "reiserfs_fs_create" function in order to 
create reiserfs filesystem on passed device with passed properties (hash, 
format, block size, standard or relocated journal, etc). <br><br>

"reiserfs_fs_create" function has two first arguments: host_dal - device 
where filesystem will be placed (superblock, bitmap, tree, etc) journal_dal - 
device where journal will be placed.<br><br>

"journal_dal" may be the same as host_dal. And this is means "mkfs" is trying 
to create filesystem with standard journal. When "journal_dal" is some other 
device  that "host_dal", it is means "mkfs" is trying to create filesystem with 
relocated journal. In this case "journal_dal" will be using in order to perform 
I/O operations on that device for working with journal.  Replaying  journal, 
looking for mapped block, etc.<br><br>

Therefore libreiserfs core code must know whether DALs are different or not. 
The libreiserfs' behavior very depends on equals callback.<br><br>

"equals"  callback  is  using also in "tune" routines. For example, when 
"tunefs" is trying to resize the journal in reiser3. If journal is standard 
then relocation of some region of tree also needed and it will be performed. 
If journal is relocated (separated) then relocation will not be performed.<br><br>

<b>int (*stat) (dal_t *dal, struct stat* st)</b>

<p>
Fills statistics buffer for dal,  like  standard  <b>stat(2)</b>.
Used by journal opening and creating routines.<br><br>

<b>blk_t (*len) (dal_t *dal)</b>

<p>
Returns  actual  device length in blocks. Used by libreiserfs in all cases 
where device length is needed. For example, it is used in reiserfs_fs_super_check.  
This functions makes some checks on opened superblock and one of them is check 
whether sb_block_count is correct (less or equals than device length).

<b>char *(*error) (dal_t *dal)</b>

<p>
Returns last error.<br>

<p>
Front-end application that wants to use libreiserfs over some specific storage, 
implements all above operations, packs them into dal_ops structure and calls 
dal_open to create DAL instance working over application-specific storage.<br><br>

DAL functions and structures are following:<br><br>

<b>dal_t *dal_open(struct dal_ops *ops, const void *dev, size_t blocksize,<br>
int flags, void *data)</b>

Allocates new instance of DAL that will use given operations. Sets blocksize
and user specific data for allocated DAL. Returns initialized instance.<br><br>

<b>void dal_close(dal_t *dal)</b>

<p>
Releases all memory associated with DAL.<br><br>

<b>int dal_set_blocksize(dal_t *dal, size_t blocksize)</b>
<b>size_t dal_blocksize(dal_t *dal)</b>

<p>
Functions to set/get block size. dal_set_blocksize makes check whether given
block size is power of two and if so, sets new blocksize. Function dal_blocksize
returns blocksize of specified DAL.<br><br>

The functions below are wrappers for operations registered in DAL's "ops" field. 
These functions also public function, which will be using by "master" project.<br><br>

<b>int dal_read(dal_t *dal, void *buff, blk_t block, blk_t count)</b>

<p>
Reads a number of blocks from DAL.<br><br>

<b>int dal_write(dal_t *dal, void *buff, blk_t block, blk_t count)</b>

<p>
Writes a number of blocks to DAL.<br><br>

<b>int dal_sync(dal_t *dal)</b>

<p>
Synchronizes specified DAL.<br><br>

<b>int dal_flags(dal_t *dal)</b>

<p>
Returns flags from DAL.<br><br>

<b>int dal_equals(dal_t *dal1, dal_t *dal2)</b>

<p>
Compares two DALs.<br><br>

<b>int dal_stat(dal_t *dal, struct stat *stat)</b>

<p>
Makes stat for specified DAL.<br><br>

<b>blk_t dal_len(dal_t *dal)</b>

<p>
Returns device length in blocks.<br><br>

<b>char *dal_error(dal_t *dal)</b>

<p>
Returns last error.<br><br>

dal_t struct has following fields:<br>

<pre>
struct dal {
	const void *dev;
	size_t blocksize;
	struct dal_ops *ops;

	int flags;
	void *data;
};
</pre>

typedef struct dal dal_t;<br><br>

<b>struct dal_ops *ops</b>

<p>
Set of operations for this device. Device operations affect the behavior of
device. See above for more details.<br><br>

<b>const void *dev</b>

<p>
The opaque pointer to device private data. For example, for "file_dal" this is
pointer to opened file descriptor, for GNU Parted this is pointer to initialized
"PedGeometry" struct, etc.<br><br>

<b>size_t blocksize</b>

<p>
The blocksize for this device. All offset calculations on it are based on this
field.<br><br>

<b>int flags</b>

<p>
The flags with which device was opened.<br><br>

<b>void *data</b>

<p>
Some device specific data. It may be used for any  purpose by particular DAL 
implementation provided by front-end. In file_dal this field are used to store 
file name in it.<br><br>

Project that doesn't need to implement a special device (due to using standard 
file descriptor), may use file_dal - device abstraction for standard device or 
file. file_dal may be used in manner like this:<br><br>

This  is  small  and stupid program for detecting reiserfs format on underlying 
device.<br>

<pre>
#include &lt;stdio.h&gt;

#include &lt;dal/dal.h&gt;
#include &lt;reiserfs/reiserfs.h&gt;

int main (int argc, char *argv[]) {
	char *dev;

	dal_t *dal;
	reiserfs_fs_t *fs;

	if (argc &lt; 2) {
		 fprintf(stderr, "Usage: %s DEV\n", argv[0]);
		 return 0xfe;
	}

	dev = argv[1];

	if (!(dal = file_dal_open(dev))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't open device %s." , dev);
		 goto error;
	}

	if (!(fs = reiserfs_fs_open(dal, dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't open reiserfs on %s.", dev);
		 goto error_free_dal;
	}

error:
	return 0xff;
}
</pre>

As DALs passed into reiserfs_fs_open are identical, this is attempt
to open filesystem with standard journal. If filesystem has relocated
journal then exception will be throwed out and NULL will be returned.

<p>
Opening of a filesystem consists of the following steps:<br><br>

initialize all internal structures; read superblock, and journal header; 
replay journal; check ournal header for validness; re-read superblock from 
the journal (if it was overwritten by journal replay); check superblock for 
validness; initialize bitmap; optionally check it for validness; initialize tree; 
read the root block, and check it for validness; return initialized filesystem instance.
</td></tr></table>

<h2>libreiserfs</h2>

<table width=80%><tr><td align=justify>
libreiserfs will consists of set of APIs. There are following: plugins API 
(plugin  factory), filesystem API, journal API, allocator API, oid allocator 
API, tree API. Also  it  will contain API (the set of wrappers functions)
for every plugin. For example, libreiserfs will be working with directory 
plugin via directory API.<br><br>

Also  libreiserfs  will  contain additional minor APIs: exceptions API, 
memory handling functions, tools.<br>

<h3>Abstraction levels in libreiserfs.</h3>

<p>
libreiserfs is structured into several abstraction layers.
Main goal of an abstraction layer is to  correctly  handle all possible 
situations and let higher abstraction layer to know what was the result.<br><br>

libreiserfs has got such abstraction levels:<br>

<ul>
	<li>lowest level: plugins, DAL.
	<li>middle level: wrappers for plugins (journal, allocator, oid allocator, etc).
	<li>highest level: filesystem (reiserfs_fs_open, reiserfs_fs_create, etc)
</ul>

In the case of an error, current abstraction layer issues error message, 
meaningful on this level, handles  error condition as much  as possible 
(by means of "exceptions" see below) and returns error code to the higher 
layer.<br><br>

For example, if journal layer (function reiserfs_journal_open) failed to 
read block from the device, it will handle error like this:<br><br>

<pre>
libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
	_("Reading block %lu failed."), blk);
return NULL;
</pre><br>
	
And return error to the higher layer (filesystem layer) instead of initialized
journal instance.

Then file system layer should handle this error like this:<br><br>

<pre>
libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
    _("Failed to open journal."));
return NULL;
</pre><br>

It issues error message, meaningful on it level and return NULL instead
initialized filesystem instance.<br><br>

etc.
</td></tr></table>

<h3>Exceptions in libreiserfs.</h3>

<table width=80%><tr><td align=justify>
Exceptions in libreiserfs are uniform way to handle errors. Contrary to 
some similarity in naming, they have nothing to with non-local exits in 
languages like C++. When using exceptions, control flow is still based 
on normal C return-and-check-error-code pattern.<br><br>

After exception is raised (thrown) it is processed by exception handled 
(currently there is single global exception handler, adding ability to 
register local exception handlers for particular types of errors is simple).<br><br>

Exception handling factory contains default exception handler and set 
of function for exception processing. Default exception handler just 
prints to the stderr a exception message and exception type (ERROR, 
WARNING, FATAL, NO_FEATURE, BUG). Default handler may be re-implemented 
and registered in libreiserfs by libreiserfs_exception_set_handler function.<br><br>

Default exception handler looks like this:<br>

<pre>
static reiserfs_exception_option_t default_handler(reiserfs_exception_t *ex) {
	if (ex-&gt;type == EXCEPTION_BUG)
		 fprintf (stderr, _("A bug has been detected in libreiserfs. "
			  "Please email a bug report to umka@namesys.com containing the version (%s) "
			  "and the following message: "), VERSION);
	else
		 fprintf (stderr, "%s: ", libreiserfs_exception_type_string(ex-&gt;type));

	fprintf (stderr, "%s\n", ex-&gt;message);

	switch (ex-&gt;options) {
		 case EXCEPTION_OK:
		 case EXCEPTION_CANCEL:
		 case EXCEPTION_IGNORE:
			  return ex-&gt;options;
		 default: return EXCEPTION_UNHANDLED;
	}
}
</pre><br>	
	
A front-end may reimplement exception handler and add  new
functionality to it.<br><br>

Exception handling functions:<br><br>

<b>typedef reiserfs_exception_option_t (reiserfs_exception_handler_t)<br>
(reiserfs_exception_t *ex);</b>

<p>
Type for exception handler function.<br><br>

<b>reiserfs_exception_option_t <br>
libreiserfs_exception_throw(reiserfs_exception_type_t type, <br>
reiserfs_exception_option_t opt, const char* message, ...);</b>

<p>
Raises (throws) an exception.<br><br>

<b>reiserfs_exception_option_t libreiserfs_exception_rethrow(void);</b>

<p>
Re-throws last exception.<br><br>

<b>void libreiserfs_exception_catch(void);</b>

<p>
Releases exception.<br><br>

<b>void libreiserfs_exception_fetch_all(void);</b>

<p>
Disables exceptions: force exception handler to just return.<br><br>

<b>void libreiserfs_exception_leave_all(void);</b>

<p>
Enables exceptions: switches back to normal handler behavior.<br>
</td></tr></table>

<h3>Gauge API.</h3>

<table width=70%><tr><td align=justify>
libreiserfs includes so called gauge API. It is the mechanism to handle progress activities
by "master" project. This mechanism is based on "gauge_handler" callback function that may be 
installed by "master" project. So, progress presentation may be changed by installing other
handler than the default handler.<br><br>

Gauge API consists of the following routines:<br><br>

<b>typedef (reiserfs_gauge_habdler_t) (const char *, unsigned int, void *, int, int, int)</b>

<p>
Type for gauge callback function. Gauge callback function accepts following parameters:<br>
<ul>
	<li>description on the current progress. For example, "Initializing journal".
	<li>current percentage.
	<li>gauge specific data.
	<li>gauge kind (may be changed online)
	<li>the flag ("bool" value) that shows whether gauge handler must update gauge header (description).
	<li>the flag ("bool" value) that shows whether gauge handler must update gauge footer.
</ul>

<b>reiserfs_gauge_t *reiserfs_gauge_create(const char *name,<br>
reiserfs_gauge_handler_t handler, void *data)</b>

<p>
Creates new gauge instance and sets it up with passed parameters.<br><br>

<b>void libreiserfs_gauge_free(reiserfs_gauge_t *gauge)</b>

<p>
Frees all gauge assosiated memory.<br><br>

<b>void libreiserfs_gauge_reset(reiserfs_gauge_t *gauge)</b>

<p>
Resets given gauge into zero.<br><br>

<b>void libreiserfs_gauge_enable(reiserfs_gauge_t *gauge),<br>
void libreiserfs_gauge_disable(reiserfs_gauge_t *gauge)</b>

<p>
Enables/disables given gauge. In the case gauge was disabled, installed gauge handler 
will not be called, until gauge will be enable.<br><br>

<b>void libreiserfa_gauge_set_handler(reiserfs_gauge_t *gauge,<br>
reiserfs_gauge_handler_t *handler)<br><br>

reiserfs_gauge_handler_t *libreiserfs_gauge_handler(reiserfs_gauge_t *gauge)
</b>

<p>
Setting up new gauge handler and getting installed gauge handler.<br><br>

<b>void libreiserfs_gauge_set_data(reiserfs_gauge_t *gauge, void *data)<br>
void *libreiserfs_gauge_data(reiserfs_gauge_t *gauge)
</b>

<p>
Setting up and getting of gauge-specified data.<br><br>

<b>void libreiserfs_gauge_set_name(reiserfs_gauge_t *gauge, const char *name)<br>
char *libreiserfs_gauge_name(reiserfs_gauge_t *gauge)
</b>

<p>
Setting up and getting of gauge's name (description).<br><br>

<b>void libreiserfs_gauge_set_value(reiserfs_gauge_t *gauge, unsigned int value)<br>
unsigned int libreiserfs_gauge_name(reiserfs_gauge_t *gauge)
</b>

<p>
Setting up and getting of gauge's current percentage.<br><br>

<b>void libreiserfs_gauge_touch(reiserfs_gauge_t *gauge)</b>

<p>
Updates given gauge. In fact gauge handler is calling in this point.<br><br>

<b>void reiserfs_gauge_done(reiserfs_gauge_t *gauge)</b>

<p>
Calls gauge handler with turned on "update_footer" flag. In this point gauge handler may 
print into standard error "done", meaning that long operation is finished.<br><br>

For example, simple gauge will roughly look:<br><br>

The first function bellow is gauge handler. It will be "drawing" the gauge into 
standard error.<br>
	
<pre>
static void progs_gauge_handler(const char *name, unsigned int value, void *data,
	int determined, int update_header, int update_footer)
{
	if (update_header) fputs(name);
		
	sprintf(display, "%d%%", value);
	fputs(display, stderr);
	fputc('\b', stderr);
	
	if (update_footer) fputs("done\n");
		
	fflush(stderr);
}

int main(int argc, char *argv[]) {
	reiserfs_gauge_t *gauge = libreiserfs_gauge_create("Test long operation", gauge_handler, 
		NULL);
	
	int percentage = 0;
	
	for (; percentage &lt; 100; i++)
		libreiserfs_gauge_set_value(percentage);

	libreiserfs_gauge_done(gauge);	
		
	libreiserfs_gauge_free(gauge);
	return 0;
}
</pre>

Gauge information will be looks like this:<br><br>

<b>"Test long operation: 35%"</b><br><br>

After long operation will be done and libreiserfs_gauge_done will be called, progress 
information will looks like this:<br><br>

<b>"Test long operation: done"</b>

</td></tr></table>

<h3>Filesystem API.</h3>

<table width=70%><tr><td align=justify>
Filesystem API will be containing all public function.<br><br>

There are general functions:<br>
reiserfs_fs_open, reiserfs_fs_close, reiserfs_fs_resize, reiserfs_fs_copy, etc.<br><br>

And some utilities:<br>
reiserfs_fs_format, reiserfs_fs_uuid, reiserfs_fs_lable,
reiserfs_fs_size, reiserfs_fs_metadata_size, etc.<br><br>

Filesystem initialization (opening) and finalization will roughly look:<br>

<pre>
struct reiserfs_fs {
	dal_t *dal;

	reiserfs_tree_t *tree;
	reiserfs_super_t *super;
	reiserfs_oid_t *oid;
	reiserfs_alloc_t *alloc;
	reiserfs_journal_t *journal;

	uint16_t flags;
};

reiserfs_fs_t *reiserfs_fs_open(dal_t *host_dal, dal_t *journal_dal) {
	blk_t root_block;
	reiserfs_fs_t *fs;
	blk_t journal_block;

	uint16_t alloc_plug_id;
	uint16_t journal_plug_id;

	ASSERT(host_dal != NULL, return NULL);
	ASSERT(journal_dal != NULL, return NULL);

	if (!(fs != libreiserfs_calloc(sizeof(*fs), 0)))
		 return NULL;

	if (!(fs-&gt;super = reiserfs_super_open(host_dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open superblock."));
		 goto error_free_fs;
	}

	journal_plug_id = super-&gt;layout_plug-&gt;u.layout.journal_plug_id();
	journal_block = super-&gt;layout_plug-&gt;u.get_journal_block();
	if (!(fs-&gt;journal = reiserfs_journal_open(journal_dal, journal_block, journal_plug_id))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open journal."));
		 goto error_free_super;
	}

	alloc_plug_id = super-&gt;layout_plug-&gt;u.layout.alloc_plug_id();
	if (!(fs-&gt;alloc = reiserfs_alloc_open(alloc_plug_id))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open allocator"));
		 goto error_free_journal
	}

	oid_plug_id = super-&gt;layout_plug-&gt;u.layout.oid_plug_id();
	if (!(fs-&gt;oid = reiserfs_oid_open(oid_plug_id))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't open oid allocator."));
		 goto error_free_alloc;
	}

	root_block = super-&gt;layout_plug-&gt;u.layout.get_root_block();
	if (!(fs-&gt;tree = reiserfs_tree_open(root_block))) {
	libreiserfs_free(fs-&gt;super);
error_free_fs:
	libreiserfs_free(fs);
error:
	return  NULL;
}

void reiserfs_fs_close(reiserfs_fs_t *fs) {
	reiserfs_journal_close(fs-&gt;journal);
	reiserfs_super_close(fs-&gt;super);
	reiserfs_alloc_close(fs-&gt;alloc);
	reiserfs_tree_close(fs-&gt;alloc);
	libreiserfs_free(fs);
}
</pre><br>

See bellow, for detailed journal and super-block code.

</td></tr></table>

<h3>Journal plugin. Journal API.</h3>

<table width=70%><tr><td align=justify>
			
Reiser4 will support several formats of the journal. In
order to support format-variable journal we need the journal 
plugin.<br><br>

I assume, that any format of journal will support at least
following properties: journal  will  be  transaction-based
and journal can be opened and closed.<br><br>

Initialization will include reading the journal header,
checking it for validness. Possibly it will build  journal
cache,  or  something  else.  The  journal  behavior fully
depends on the journal plugin. Then  journal  plugin  will
prepare initialized journal instance and will returns it to
caller.<br><br>

Journal plugin interface will depends on common journal 
parameters for every journal format. As reiser4 will support 
old journal format, journal plugin must export interface to 
obtain such parameters: start, length, max_trans_size, etc. 
Also interface must let to do something with the journal 
(tuning, resizing, etc).<br><br>

Besides, libreiserfs code must know where journal is
placed. Especially standard journal in reiser3. Journal
plugin  must  have an journal-internals independent interface.<br>

<pre>
typedef void reiserfs_opaque_t;

struct reiserfs_journal_plug {
	reiserfs_opaque_t *(*init) (dal_t *dal);
	reiserfs_opaque_t *(*create) (dal_t *dal);
	void (*done) (reiserfs_opaque_t *);

	/* Journal routines which are common in reiser3 and reiser4 journal format */
	int (*replay) (reiserfs_opaque_t *, int is_replay);
	int (*alterable) (reiserfs_opaque_t *);

	/* Journal routines which are specific for reiser3 journal format */
	int (*resize) (reiserfs_opaque_t *, blk_t, blk_t);
	void (*boundaries) (reiserfs_opaque_t *, blk_t *, blk_t *);

	/* Calls for obtaining and modifying journal parameters */
};
</pre><br>

<b>reiserfs_opaque_t *(*init) (dal_t *dal)</b>

<p>
Opens journal (reading the header and checking it for errors) and returns
initialized journal instance. This instance will be using to working with
journal.<br><br>

<b>reiserfs_opaque_t *(*create) (dal_t *dal)</b>

<p>
Creates the journal on specified DAL. Opens created journal by "init" call
and returns initialized journal instance.<br><br>

<b>void (*done) (reiserfs_opaque_t *)</b>

<p>
Closes journal. Frees all internal structures.<br><br>

<b>int (*replay) (reiserfs_opaque_t *, int is_replay)</b>

<p>
Replays journal. Returns result of replaying.<br><br>

<b>int (*alterable) (reiserfs_opaque_t *)</b>

<p>
Returns "bool" value that means whether journal can be resized, tuned or not.<br><br>

<b>void (*boundaries) (reiserfs_opaque_t *, blk_t *, blk_t *)</b>

<p>
Returns journal boundaries for journal in reiser3. As journal in reiser4 will
has not exactly defined boundaries, this function will do nothing or will be
uninitialized.<br><br>

Journal API will be a set of wrapper functions for journal plugin. 
There following: reiserfs_journal_create, reiserfs_journal_open,
reiserfs_journal_close, reiserfs_journal_replay, reiserfs_journal_resize, 
etc.

Also it will contain common code for all journal formats.<br>

<pre>
struct reiserfs_journal {
	dal_t *dal;
	reiserfs_opaque_t *journal_instance;
	reiserfs_plug_t *journal_plug;
};

typedef struct reiserfs_journal reiserfs_journal_t;
</pre>

<b>dal_t *dal</b>

<p>
DAL where journal lies.<br><br>

<b>reiserfs_opaque_t *journal_instance</b>

<p>
Pointer to initialized journal instance. Will be using later to interact with
underlying journal.<br><br>

<b>reiserfs_plug_t *journal_plug</b>

<p>
Journal format plugin.<br><br>

Journal initialization and finalization will roughly look:<br>

<pre>
reiserfs_journal_t *reiserfs_journal_open(dak_t *dal, blk_t journal_block,
	uint16_t journal_plug_id)
{
	reiserfs_opaque_t *journal_instance;
	reiserfs_journal_t *journal;
	reiserfs_plug_t *journal_plug;

	if (!(journal_plug = reiserfs_plug_load(REISERFS_PLUG_JOURNAL, journal_plug_id)))
		 return NULL;

	if (!(journal_instance = journal_plug-&gt;u.journal.init(dal))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't initialize journal."));
		 return NULL;
	}

	if (!(journal = libreiserfs_calloc(sizeof(*journal), 0)))
		 goto error_free_journal_instance;
	
	journal-&gt;journal_block = journal_block;
	journal-&gt;journal_plug = journal_plug;
	journal-&gt;journal_instance = journal_instance;

	/* Optional journal replaying */

	return journal;

error_free_journal_instance:
	libreiserfs_free(journal_instance);
error:
	return NULL;
}
		 
void reiserfs_journal_close(reiserfs_journal_t *journal) {
	ASSERT(journal != NULL, return);

	journal-&gt;journal_plug-&gt;u.journal-&gt;done(journal-&gt;journal_instance);
	reiserfs_plug_unload(journal-&gt;journal_plug);
	libreiserfs_free(journal);
}
</pre>
</td></tr></table>

<h3>Disk-Format plugin. Superblock API.</h3>

<table width=70%><tr><td align=justify>
			
Disk-Format plugin defines filesystem layout at general.
First of all it defines where the superblock lies and what
the format this superblock has.<br><br>

Also it exports interface for getting/setting values from/to superblock.<br><br>

Therefore all available disk-format plugins must be loaded
during library initialization  time,  just  after  plugin
cache will be initialized in order to be able to find any
superblock at filesystem opening time.<br><br>

Also  disk-format plugin defines  where  root  block  is
located, etc. It will look like this:<br>

<pre>
struct reiserfs_layout_plug {
	reiserfs_opaque_t *(*init) (dal_t *);
	void (*done) (reiserfs_opaque_t *);

	uint16_t (*alloc_plug_id) (reiserfs_opaque_t *);
	uint16_t (*oid_plug_id) (reiserfs_opaque_t *);
	uint16_t (*journal_plug_id) (reiserfs_opaque_t *);

	/* Routines for working with superblock */
	blk_t (*get_journal_block) (reiserfs_opaque_t *);
	void (*set_journal_block) (reiserfs_opaque_t *, blk_t);

	blk_t (*get_block_count) (reiserfs_opaque_t *);
	void (*set_block_count) (reiserfs_opaque_t *, blk_t);

	blk_t (*get_free_blocks) (reiserfs_opaque_t *);
	void (*set_free_blocks) (reiserfs_opaque_t *, blk_t);

	blk_t (*get_root_block) (reiserfs_opaque_t *);
	void (*set_root_block) (reiserfs_opaque_t *, blk_t);

	uint16_t (*get_tree_height) (reiserfs_opaque_t *);
	void (*set_tree_height) (reiserfs_opaque_t *, uint32_t);

	uint64_t (*get_oid) (reiserfs_opaque_t *);
	void (*set_oid) (reiserfs_opaque_t *, uint64_t);

	uint64_t (*get_file_count) (reiserfs_opaque_t *);
	void (*set_file_count) (reiserfs_opaque_t *, uint64_t);
};

typedef struct reiserfs_layout_plug reiserfs_layout_plug_t;
</pre>

<b>reiserfs_opaque_t *(*init) (dal_t *)</b>

<p>
Returns oid allocator plugin's ID. Will be used  in  order
to  find oid allocator plugin in plugins cashe and plugins
map.<br><br>

<b>uint16_t (*alloc_plug_id) (reiserfs_opaque_t *)</b>

<p>
Returns allocator's plugin ID. Will used in order to  find
needed allocator plugin.<br><br>

<b>blk_t (*get_journal_block) (reiserfs_opaque_t *)<br>
reiserfs_opaque_t(*set_journal_block) (reiserfs_opaque_t *, blk_t)</b>

<p>
Gets/sets the block where journal header is lies.<br><br>

<b>blk_t (*get_block_count) (reiserfs_opaque_t *)<br>
reiserfs_opaque_t(*set_block_count) (reiserfs_opaque_t *, blk_t)</b>

<p>
Gets/sets  "block_count" field of super block of this layout.<br><br>

<b>blk_t (*get_free_blocks) (reiserfs_opaque_t *)<br>
reiserfs_opaque_t(*set_free_blocks) (reiserfs_opaque_t *, blk_t)</b>

<p>
Gets/sets "free_blocks" field of super block of this  layout.<br><br>

<b>blk_t (*get_root_block) (reiserfs_opaque_t *)<br>
reiserfs_opaque_t(*set_root_block) (reiserfs_opaque_t *, blk_t)</b>

<p>
Gets/sets  "root_block"  field of super block of this layout.<br><br>

<b>uint16_t (*get_tree_height) (reiserfs_opaque_t *)<br>
reiserfs_opaque_t(*set_tree_height) (reiserfs_opaque_t *, uint16_t)</b>

<p>
Gets/sets field "tree_height" of super block of this  layout.<br><br>

<b>uint64_t (*get_oid) (reiserfs_opaque_t *) reiserfs_opaque_t(*set_oid) <br>
(reiserfs_opaque_t *, uint64_t)</b>

<p>
Gets/sets "oid" field of super block of this layout.<br><br>

<b>uint64_t (*get_file_count) (reiserfs_opaque_t *) <br>
reiserfs_opaque_t(*get_file_count) (reiserfs_opaque_t *, uint64_t)</b>

<p>
Gets/sets "file_count" of super block of this layout.<br><br>

Superblock API will be a set of wrapper functions for Disk-Format plugin.
It will include the following: reiserfs_super_open, reiserfs_super_close, 
reiserfs_super_update_magic, etc.

Superblock initialization and finalization routins will roughly look:<br>

<pre>
struct reiserfs_super {
	reiserfs_opaque_t *layout_instance;
	reiserfs_plug_t *layout_plug;
};
typedef struct reiserfs_super reiserfs_super_t;
</pre>

<b>reiserfs_plug_t *layout_plug</b>

<p>
The pointer to layout_plugin<br><br>

<b>reiserfs_opaque_t *layout_instance</b>

<p>
Pointer to initialized instance of some layout. Will be using later
for working with that layout.<br>

<pre>
reiserfs_super_t *reiserfs_super_open(dal_t *dal) {
   int i;
   reiserfs_super_t *super;
   reiserfs_opaque_t *layout_instance = NULL;
   reiserfs_plug_t *layout_plug = NULL;

   for (i = 0; i &lt; plug_count; i++) {
	   if (plugs[i]-&gt;plug_kind != REISERFS_PLUG_DISK_LAYOUT)
		  continue;

	   if ((layout_instance = plugs[i]-&gt;u.layout.init(dal))) {
			layout_plug = plugs[i];
			break;
	   }
	}

	if (!layout_plug) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  _("Couldn't find any disk layout."));
		 return NULL;
	}

	if (!(super = libreiserfs_calloc(sizeof(*super), 0)))
		 return NULL;

	super-&gt;layout_plug = layout_plug;
	super-&gt;layout_instance = layout_instance;

	return super;
}

void reiserfs_super_close(reiserfs_super_t *super) {
	ASSERT(super != NULL, return);

	super-&gt;layout_plug-&gt;u.layout-&gt;done(super-&gt;layout_instance);

	libreiserfs_free(journal);
}
</pre>

</td></tr></table>

<h3>Allocator plugin. Allocator API.</h3>

<table width=70%><tr><td align=justify>

A replica of bitmap in reiser3. There will be functions:<br><br>

reiserfs_alloc_open, reiserfs_alloc_create, reiserfs_alloc_close,  
reiserfs_alloc_use, reiserfs_alloc_unuse, reiserfs_alloc_find, 
reiserfs_alloc_resize, reiserfs_alloc_copy, reiserfs_alloc_clone.
</td></tr></table>

<h3>Balanced Tree API.</h3>

<table width=70%><tr><td alalign=justify>
There functions for working with b*tree. There following:<br><br>

<b>reiserfs_tree_t *reiserfs_tree_open(reiserfs_fs_t *fs)</b>

<p>
Opens balanced tree on the specified filesystem. It reads root block, checks it for 
validness, allocates reiserfs_tree_t instance and returns it to caller. This function 
is called by reiserfs_fs_open function in the initialization time.<br><br>

<b>reiserfs_tree_t *reiserfs_tree_create(reiserfs_fs_t *fs)</b>

<p>
Create balanced tree on the specified filesystem. It composes the root block of the 
tree, and stores it on "host_dal" device of given filesystem. Also allocates 
reiserfs_tree_t instance and returns it to caller. This function is used durring 
filesystem creation by reiserfs_fs_create function.<br><br>

<b>void reiserfs_tree_t *reiserfs_tree_close(reiserfs_tree_t *tree)</b>

<p>
Frees all memory assosiated with tree.<br><br>

<b>int reiserfs_tree_lookup_internal(reiserfs_tree_t *tree, blk_t from, <br>
reiserfs_comp_func_t *comp_func, struct key *key, reiserfs_path_t *path)</b>

<p>
Makes looking up for specified key in the balanced tree. Stops search on the last 
found internal node. Fills "path" by tracked path. For comparing keys in tree is 
used "comp_func" callback function. "reiserfs_tree_lookup_internal" functions is 
used by tree modification routines in order to find the internal node, we should 
insert new formated node in it.<br><br>

<b>int reiserfs_tree_lookup_leaf(reiserfs_tree_t *tree, blk_t from, <br>
reiserfs_comp_func_t *comp_func, struct key *key, reiserfs_path_t *path)</b>

<p>
Makes looking up for specified key in the balanced tree. Stops serach on the found 
leaf node. Fills "path" by tracked path. For comparing keys in tree is used "comp_func" 
callback function. Is used by tree modification routines in order to find the leaf in 
the tree, and the position inside found leaf where we should insert new item. It is 
also used by file and directory APIs.
<br><br>

<b>long reiserfs_tree_traverse(reiserfs_tree_t *tree, void *data,<br>
reiserfs_edge_traverse_func_t before_node_func, reiserfs_node_func_t node_func,<br>
reiserfs_chld_func_t chld_func, reiserfs_edge_traverse_func_t after_node_func)</b>

<p>
Makes full traversing in the balanced tree. For all "node-specific" operations for every 
formated node uses a set of callback functions. Traversing may be stoped in any point 
if an callback function returns "bool" false value.<br><br>

This is the central function for all following operations:<br><br>

resizing, smart resizing (resize filesystem by start and end parameters), copying, 
relocating (relocates specified region of the balanced tree onto other specified region), 
journal resizing, journal relocating, etc.<br><br>

There will be routines for modifying the balanced tree (We have to discuss it).

</td></tr></table>

<h3>Plugins map.</h3>

<table width=70%><tr><td align=justify>
Plugins map keeps correspondence between plugin's coords (KIND, ID) and library for 
this plugin.<br>
</td></tr></table>

<h3>Plugins factory.</h3>

<table width=70%><tr><td align=justify>
In the initialization time libreiserfs will initialize plugins factory 
with plugins cache that will store loaded plugins. Plugin cache keeps 
track of loaded plugins and allows to avoid duplicate loading of the 
same plugin.<br><br>

During filesystem open library will determine what journal plugin to 
use. Corresponding plugin will be located, loaded and stored in the 
cache. After that, filesystem open will proceed further.<br><br>

The all other plugins will be loaded on demand and stored in plugin 
cache. And all subsequent requests to load the same plugin will be 
satisfied from the cache.<br><br>

Plugins loading code and data-structures look roughly like following:<br><br>

<pre>
#define REISERFS_PLUG_MAX_NAME          255
#define REISERFS_PLUG_MAX_DESC          255

#define REISERFS_PLUG_MAX_KIND          255
#define REISERFS_PLUG_MAX_TYPE          255

extern reiserfs_plug_t *plug_cashe[REISERFS_PLUG_MAX_KIND][REISERFS_PLUG_MAX_TYPE];

enum reiserfs_plug_kind {
	REISERFS_PLUG_JOURNAL              = 1 &lt;&lt; 0,
	REISERFS_PLUG_DIR                  = 1 &lt;&lt; 1,
	REISERFS_PLUG_FILE                 = 1 &lt;&lt; 2,
	REISERFS_PLUG_ITEM                 = 1 &lt;&lt; 3
	...
};

typedef enum reiserfs_plug_kind reiserfs_plug_kind_t;

struct reiserfs_plug_header {
   uint32_t plug_id;
   reiserfs_plug_kind_t plug_kind;
   const char plug_name[REISERFS_PLUG_MAX_NAME];
   const char plug_desc[REISERFS_PLUG_MAX_DESC];
   void *plug_data;
};

typedef struct reiserfs_plug_header reiserfs_plug_header_t;

struct reiserfs_plug {
	void *plug_handle;
	uint32_t plug_nlink;

	reiserfs_plug_header_t header;

	union {
		 reiserfs_journal_plug_t journal;
		 reiserfs_alloc_plug_t alloc;
		 reiserfs_layout_plug_t layout;
		 reiserfs_security_plug_t security;
		 reiserfs_dir_plug_t dir;
		 reiserfs_file_plug_t file;
		 reiserfs_node_plug_t node;
		 reiserfs_item_plug_t item;
	} __attribute__ (__packed__) u;
};

typedef struct reiserfs_plug reiserfs_plug_t;
</pre><br>

<b>void *plug_handle</b>

<p>
Handle of loaded shared library.<br><br>

<b>uint32_t plug_nlink</b>

<p>
Number of references on underlying plugin. This value is initializing by zero
during first time loading. It is incrementing by reiserfs_plug_load function
and decrementing by reiserfs_plug_unload function. If "plug_nlink" reaches zero,
then plugin will be unloaded.<br><br>

<b>uint32_t plug_id</b>
<b>reiserfs_plug_kind_t plug_kind</b>

<p>
Plugin identifier and kind/type. Used to look plugin up in the plugin cache.
Also used for looking in the plugins map in order to found required plugin
library. For, example: plug_id = 0x01, plug_kind = 0x01, file = libreiserfs_journal40.so<br><br>

<b>const char plug_name[REISERFS_PLUG_MAX_NAME]</b>

<p>
Plugin name. For example, "journal40". Will be used to looking plug up
by it "plug_name".<br><br>

<b>const char plug_desc[REISERFS_PLUG_MAX_DESC]</b>

<p>
Plugin description. For example, "This is the standard journal plugin for Reiser4".<br><br>

<b>union {...} u;</b>

<p>
Plugin instance.<br>

<pre>
reiserfs_plug_t *reiserfs_plug_load_by_name(const char *name) {
	char *error;
	void *plug_handle;
	void *plug_entry;
	reiserfs_plug_t *plug;
	reiserfs_plug_t *(*gpi) (void);

	ASSERT(name != NULL, return NULL);

	if (!(plug_handle = dlopen(name, RTLD_NOW))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't load plugin %s.", name);
		 goto error;
	}

	plug_entry = dlsym(plug_handle, "reiserfs_plugin_info");
	if ((error = dlerror()) != NULL) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, PED_EXCEPTION_IGNORE,
			  _("Couldn't resolve symbol %s. Error: %s."), reiserfs_plugin_info, error);
		 goto error_free_plug_handle;
	}
	gpi = (reiserfs_plug_t *(*)(void))plug_entry;

	plug = gpi();

	plug-&gt;plug_handle = plug_handle;
	plug-&gt;plug_nlink = 0;

	reiserfs_plugin_register(plug);

	return plug;

error_free_plug_handle:
	dlclose(plug_handle);
error:
	return NULL;

}

reiserfs_plug_t *reiserfs_plug_load(reiserfs_plug_kind_t plug_kind, uint32_t plug_id) {
	char *plug_name;
	reiserfs_plug_t *plug;

	/* First of all we are trying to find loaded plugin in plugins cache by it id */
	if ((plug = reiserfs_plug_find(plug_id))) {
		 plug-&gt;plug_nlink++;
		 return plug;
	}

	if (!(plug_name = reiserfs_plug_path_by_id(plug_kind, plug_id))) {
		 libreiserfs_exception_throw(EXCEPTION_ERROR, EXCEPTION_CANCEL,
			  "Couldn't find registered plugin by it identifier %d.", plug_id);
		 goto error;
	}

	if (!(plug = reiserfs_plug_load_by_name(plug_name)))
		 goto error;
		 reiserfs_plug_unregister(plug);
		 dlclose(plug-&gt;header.plug_handle);
	}
}
</pre><br>

As you can see loaded plugins are registering in the  plugin cashe.<br><br>

There  will  be  set  of functions (reiserfs_plugin_*) for
working with plugins.<br><br>

<b>int reiserfs_plug_register(reiserfs_plug_t *plug)</b>

<p>
Registers initialized plugin in the plugins cache. Returns
true on success, false on failure.<br><br>

<b>int reiserfs_plug_unregister(reiserfs_plug_t *plug)</b>

<p>
Unregisters of given plugin.<br><br>

<b>reiserfs_plug_t *reiserfs_plug_load(uint16_t plug_kind, uint16_t plug_id)</b>

<p>
Loads plugin by identifier. If plugin is  already  loaded,
retrieves  it  from the cache. If not, loads it and stores
loaded plugin in the cache.<br><br>

<b>int reiserfs_plug_unload(reiserfs_plug_t *plug)</b>

<p>
Unloads plugin, unregisters it from cache if "plugin_nlink" field reaches zero. <br><br>

In the finalization time, plugin factory will release all plugins.
</td></tr></table><br>

<i>Copyright 1996-2002 Hans Reiser</i>

</body>
</html>
