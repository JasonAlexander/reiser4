SYS_REISER4 IMPLEMENTATION OVERVIEW


A. Basics
*****************************************************************

sys_reiser4() system call executing a sequence of actions upon the
file-system(s). Actions are specified by the user in a form of command
string. For the purposes of present discussion, said command string can be
thought of as a program in a special purpose programming language, which will
be further referred to as rsccl (reiser4 system call command language,
presumably pronounced as "rascal").

Canonical example of rsccl program is

/dir1/dir2/dir3/file1 <- /dir4/dir5/dir6/file2

It semantics is following:

1. resolve "/dir1/dir2/dir3/file1" into file-system object (lookup operation)
2. resolve "/dir4/dir5/dir6/file2" into file-system object (lookup operation)
3. assign latter to the former.

This is "assignment" operator. Assignment involves two "file-system objects"
and semantics of both lookup stage and assignment proper depends upon type of
the file-system object.

Following types of file-system objects are recognized:

1. foreign objects: objects of different file-systems. [In the initial
version,] foreign object cannot be target or source of an assignment. Rather,
foreign objects can only appear during path name lookup, while traversing
non-reiser4 part of the file-system name-space. Probably one should
distinguish between objects belonging to different file-system types (etx2,
NFS) and objects belonging to different reiser4 mounts.

2. reiser4 objects.

3. pseudo-objects: these are entities injected into reiser4 name-space to
provide uniform access to various file-system meta-data. Pseudo-objects are
(usually) attached to some particular "host" object. [In the initial version,]
host objects are reiser4 objects. [Later it is possible to implement some
pseudo-objects for foreign objects.] Convention (but not enforced rule) is
that pseudo-objects are accessible through names starting with some well-known
prefix (".." is current favorite). Examples: ..owner, ..acl, etc. See comment
at the top of fs/reiser4/plugin/pseudo/pseudo.c for more details.

B. lnodes
*****************************************************************

lnodes are handles for file-system objects described above. They serve dual
purpose:

1. uniform interface to the various types of objects. This allows rsccl
implementation to treat various types of objects in the same manner. When new
type of object has to be added, all changes will be grouped in one place,
rather than scattered across various files. This uniformity also allows code
sharing between rsccl and VFS access paths. For example, the same ->write
method can be used by both.

2. synchronization. rsccl doesn't use inodes and this poses a problem of
synchronization with VFS. Each lnode serves as a lock. See lnode.c for more
details.

C. lookup
*****************************************************************

[In initial version,] we still support only two traditional UNIX kinds of
pathnames: absolute and relative to the current working directory. In both
cases, lookup starts from some file-system object represented by lnode. Then
lookup proceeds component-by-component as follows:

   lnode *parent;
   lnode  child;

   ret_code = lnode_get_dir_plugin( parent ) -> lnode_by_name( parent, 
                                                               path_component,
                                                               &child );

1. Abovementioned locking issues require that parent lnode has to be kept
until operation on child finishes. In effect we get lock-coupling much like in
internal tree traversal.

2. Mount points crossing. It is possible, because dentries and therefore
inodes of all mount points are pinned in memory and lookup code can check at
each step whether mount point is crossed. Details are not very nice, because
for each inode in a path we have to scan list of all its dentries and check
whether correct one (corresponding to our path) is mount point.

D. assignment
*****************************************************************

Assignment A<-B basically means duplicating content of B into A. No
copy-on-write optimizations are planned at this stage.

Assignment implementation is based on the notion of flow (flow_t). Flow is a
source from which data can be obtained. Flow can be "backed up" by one of the
following:

1. memory area in user space. (char *area, size_t length)
2. memory area in kernel space. (caddr_t *area, size_t length)
3. file-system object (lnode *obj, loff_t offset, size_t length)

Main function to manipulate flows is:

int flow_place( flow_t *flow, char *area, size_t length );

it copies @length bytes of @flow into @area and updated @flow correspondingly.
Behavior of flow_place() depends on the type of entity backing up @flow. If
@flow is based on the kernel-space area, memmove() is used to copy data. If
@flow is based on the user-space area, copy_from_user() is used. If @flow is
based on file-system object, flow_place() loads object's data into page cache
and copies them into @area.

Thus, assignment code looks like following:

int reiser4_assign( lnode *dst, lnode *src )
{
    flow_t flow;
    int    ret_code;
    int    offset;
    
    offset = 0;
    ret_code = lnode_get_body_plugin( src ) -> build_flow( src, &flow, offset );
    while( flow_not_empty( &flow ) ) {
        char  *area;
        size_t length;

        /* 
         * append some space to @dst. Reasonable implementation will allocate
         * several pagesful here 
         */
        ret_code = lnode_get_body_plugin( dst ) -> prepare_append( dst, 
                                                                   &area, 
                                                                   &length );
        /*
         * put data from flow into newly alloted space. This also updates
         * @flow.
         */
        flow_place( flow, area, length );
        /*
         * perform necessary post-write activity required by @dst plugin, like
         * encryption, compression, etc.
         */
        ret_code = lnode_get_body_plugin( dst ) -> commit_append( dst, 
                                                                  area, length );
    }
}


E. parsing
*****************************************************************

It is not clear what parts of rsccl processing should go into kernel. In any
case, providing direct system call as main (or, worse, the only) way to access
rsccl functionality bounds as to maintain binary compatibility in a future. To
avoid this, reiser4 should be shipped with user-level library, containing

int reiser4( const char *cmd, size_t length );

function. For now, this function will directly despatch @cmd to the
sys_reiser4() in a future, it may do parsing itself and pass parse tree to the
kernel interpreter.

*****************************************************************

# Local variables:
# mode-name: "proposal"
# indent-tabs-mode: nil
# tab-width: 4
# eval: (if (fboundp 'flyspell-mode) (flyspell-mode))
# End:
