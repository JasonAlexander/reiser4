/* Copyright 2001, 2002 by Hans Reiser, licensing governed by reiser4/README */

/* Handling of "pseudo" files representing unified access to meta data in
   reiser4. */

/* 
   See http://namesys.com/v4/v4.html, and especially
   http://namesys.com/v4/v4.html#syscall for basic information about reiser4
   pseudo files, access to meta-data, reiser4() system call, etc.
  
   Pseudo files should be accessible from both reiser4() system call and
   normal POSIX calls.
  
   IMPLEMENTATION
  
       Pseudo files are implemented as normal inodes, living in the same super
       block as other inodes for reiser4 file system. Their inode numbers are
       generated by fs/inode.c:new_inode() function and are not persistent (in
       the sense that they are not guaranteed to be the same after
       remount). To avoid clashes with "normal" inodes, all pseudo inodes are
       placed into otherwise unused locality (for example, 0), hence allowing
       reiser4_inode_find_actor() to tell them from normal inodes.

       All pseudo inodes share the same object plugin
       PSEUDO_FILE_PLUGIN_ID. In pseudo-inode specific part of reiser4_inode
       (pseudo_info), two things are stored:

           1. pointer to the inode of the "host object" (for /a/b/c/..acl,
           /a/b/c is the host object)

	   2. pointer to pseudo plugin, used by PSEUDO_FILE_PLUGIN_ID to
	   implement VFS operations.

       This design has following advantages:

           1. provides for ease addition of new pseudo files without going
           through writing whole new object plugin.

           2. allows sys_reiser4() to be implemented by directory invoking
           pseudo plugin methods.

   OLD COMMENTS. REMOVE EVENTUALLY.

     When assigning inode numbers to pseudo files, we use the last 2^62 oids
     of the 64 oid space.
  
     We implement each type of pseudo file ("..key", "..foo") as new object plugin in
     addition to the standard object plugins (regular file, directory, pipe,
     and so on).
  
     Pseudo file inodes require a pointer to the "host" object inode.
  
     Adding yet another field to the generic reiser4_inode that will
     only be used for the pseudo file seems to be an excess. Moreover, each pseudo file type can
     require its own additional state, which is hard to predict in advance,
     and ability to freely add new pseudo file types with rich and widely different
     semantics seems to be important for the reiser4.
  
     This difficulty can be solved by observing that some fields in reiser4
     private part of inode are meaningless for pseudo files. Examples are: tail, hash,
     and stat-data plugin pointers, etc.
  
   PROPOSED SOLUTION

     So, for now, we can reuse locality_id in reiser4 private part of inode to
     store number of host inode of pseudo file, and create special object plugin for
     each pseudo file type. 
  
     That plugin will use some other field in reiser4 private
     inode part that is meaning less for pseudo files (->extmask?) to
     determine type of pseudo file and use appopriate low level pseudo file operations
     (pseudo_ops) to implement VFS operations.
  
Use the pluginid field?

  
     All this (hack-like) machinery has of course nothing to do with reiser4()
     system call that will use pseudo_ops directly.

 We do however need to define the methods that the reiser4 system call will use.

  
   NOTES
  
    Special flag in inodes_plugins->flags to detect pseudo file.
(The plugin id?)
    Mark pseudo file inode as loaded: ->flags | REISER4_LOADED
  
*/

#include "../../inode.h"
#include "../../debug.h"
#include "../plugin.h"

#include "pseudo.h"

static int init_pseudo(struct inode *parent, struct inode *pseudo,
		       pseudo_plugin *pplug, const char *name);

static struct inode *add_pseudo(struct inode *parent, 
				pseudo_plugin *pplug, struct dentry *d);

static void pseudo_set_datum(struct inode *pseudo, unsigned long datum)
{
	reiser4_inode_data(pseudo)->file_plugin_data.pseudo_info.datum = datum;
}

int
lookup_pseudo_file(struct inode *parent, struct dentry * dentry)
{
	reiser4_plugin *plugin;
	const char     *name;
	struct inode   *pseudo;
	int             result;

	assert("nikita-2999", parent != NULL);
	assert("nikita-3000", dentry != NULL);

	if (reiser4_is_set(parent->i_sb, REISER4_NO_PSEUDO))
		return RETERR(-ENOENT);

	name = dentry->d_name.name;
	pseudo = ERR_PTR(-ENOENT);
	for_all_plugins(REISER4_PSEUDO_PLUGIN_TYPE, plugin) {
		pseudo_plugin *pplug;

		pplug = &plugin->pseudo;
		if (pplug->try != NULL && pplug->try(pplug, parent, name)) {
			pseudo = add_pseudo(parent, pplug, dentry);
			break;
		}
	}
	if (!IS_ERR(pseudo))
		result = 0;
	else
		result = PTR_ERR(pseudo);
	return result;
}

static struct inode *add_pseudo(struct inode *parent, 
				pseudo_plugin *pplug, struct dentry *d)
{
	struct inode *pseudo;

	pseudo = new_inode(parent->i_sb);
	if (pseudo != NULL) {
		int result;

		result = init_pseudo(parent, pseudo, pplug, d->d_name.name);
		if (result != 0)
			pseudo = ERR_PTR(result);
		else
			d_add(d, pseudo);
	} else
		pseudo = ERR_PTR(RETERR(-ENOMEM));
	return pseudo;
}


static int 
init_pseudo(struct inode *parent, struct inode *pseudo,
	    pseudo_plugin *pplug, const char *name)
{
	int result;
	reiser4_inode *idata;
	reiser4_object_create_data data;
	static const oid_t pseudo_locality = 0x0ull;

	idata = reiser4_inode_data(pseudo);
	idata->locality_id = pseudo_locality;
	idata->file_plugin_data.pseudo_info.host   = parent;
	idata->file_plugin_data.pseudo_info.plugin = pplug;

	data.id   = PSEUDO_FILE_PLUGIN_ID;
	data.mode = pplug->lookup_mode;

	plugin_set_file(&idata->pset, file_plugin_by_id(PSEUDO_FILE_PLUGIN_ID));
	if (pplug->lookup != NULL)
		plugin_set_dir(&idata->pset, 
			       dir_plugin_by_id(PSEUDO_DIR_PLUGIN_ID));

	result = inode_file_plugin(pseudo)->set_plug_in_inode(pseudo, 
							      parent, &data);
	if (result != 0) {
		warning("nikita-3203", "Cannot install pseudo plugin");
		print_plugin("plugin", pseudo_plugin_to_plugin(pplug));
		return result;
	}

	grab_plugin(idata, reiser4_inode_data(parent), perm);

	pseudo->i_nlink = 1;
	/* insert inode into VFS hash table */
	insert_inode_hash(pseudo);
	return 0;
}

static struct inode *get_inode_host(struct inode *inode)
{
	return reiser4_inode_data(inode)->file_plugin_data.pseudo_info.host;
}

static struct inode *get_pseudo_host(struct file *file)
{
	struct inode *inode;

	inode = file->f_dentry->d_inode;
	return get_inode_host(inode);
}

static struct inode *get_seq_pseudo_host(struct seq_file *seq)
{
	struct file *file;

	file = seq->private;
	return get_pseudo_host(file);
}


static int try_by_label(pseudo_plugin *pplug, 
			const struct inode *parent, const char *name)
{
	return !strcmp(name, pplug->h.label);
}

static int show_uid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lu", (long unsigned)get_seq_pseudo_host(seq)->i_uid);
	return 0;
}

static int check_perm(struct inode *inode)
{
	if (IS_RDONLY(inode))
		return RETERR(-EROFS);
	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
		return RETERR(-EPERM);
	return 0;
}

static int update_ugid(struct dentry *dentry, struct inode *inode,
		       uid_t uid, gid_t gid)
{
	int result;

	/* logic COPIED from fs/open.c:chown_common() */
	result = check_perm(inode);
	if (result == 0) {
		struct iattr newattrs;

		newattrs.ia_valid =  ATTR_CTIME;
		if (uid != (uid_t) -1) {
			newattrs.ia_valid |= ATTR_UID;
			newattrs.ia_uid = uid;
		}
		if (gid != (uid_t) -1) {
			newattrs.ia_valid |= ATTR_GID;
			newattrs.ia_gid = gid;
		}
		if (!S_ISDIR(inode->i_mode))
			newattrs.ia_valid |= ATTR_KILL_SUID|ATTR_KILL_SGID;
		down(&inode->i_sem);
		result = notify_change(dentry, &newattrs);
		up(&inode->i_sem);
	}
	return result;
}

static int get_uid(struct file *file, const char *buf)
{
	uid_t uid;
	int result;

	if (sscanf(buf, "%i", &uid) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = update_ugid(file->f_dentry->d_parent, host, uid, -1);
	} else
		result = RETERR(-EINVAL);
	return result;
}

static int show_gid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lu", (long unsigned)get_seq_pseudo_host(seq)->i_gid);
	return 0;
}

static int get_gid(struct file *file, const char *buf)
{
	gid_t gid;
	int result;

	if (sscanf(buf, "%i", &gid) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = update_ugid(file->f_dentry->d_parent, host, -1, gid);
	} else
		result = RETERR(-EINVAL);
	return result;
}

static int show_oid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%llu", get_inode_oid(get_seq_pseudo_host(seq)));
	return 0;
}

static int show_key(struct seq_file *seq, void *cookie)
{
	/* (%Lx:%x:%Lx:%Lx:%Lx) = 1 + 16 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 16 + 1 */
	char buf[60];
	reiser4_key key;

	sprintf_key(buf, build_sd_key(get_seq_pseudo_host(seq), &key));
	seq_printf(seq, "%s", buf);
	return 0;
}

static int show_size(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lli", get_seq_pseudo_host(seq)->i_size);
	return 0;
}

static int show_nlink(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%u", get_seq_pseudo_host(seq)->i_nlink);
	return 0;
}

static int show_locality(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%llu", 
		   reiser4_inode_data(get_seq_pseudo_host(seq))->locality_id);
	return 0;
}

static int show_rwx(struct seq_file *seq, void *cookie)
{
	umode_t      m;

	m = get_seq_pseudo_host(seq)->i_mode;
	seq_printf(seq, "%#ho %c%c%c%c%c%c%c%c%c%c",
		   m,

		   S_ISREG(m) ? '-' : 
		   S_ISDIR(m) ? 'd' : 
		   S_ISCHR(m) ? 'c' : 
		   S_ISBLK(m) ? 'b' : 
		   S_ISFIFO(m) ? 'p' : 
		   S_ISLNK(m) ? 'l' : 
		   S_ISSOCK(m) ? 's' : '?',

		   m & S_IRUSR ? 'r' : '-',
		   m & S_IWUSR ? 'w' : '-',
		   m & S_IXUSR ? 'x' : '-',

		   m & S_IRGRP ? 'r' : '-',
		   m & S_IWGRP ? 'w' : '-',
		   m & S_IXGRP ? 'x' : '-',

		   m & S_IROTH ? 'r' : '-',
		   m & S_IWOTH ? 'w' : '-',
		   m & S_IXOTH ? 'x' : '-');
	return 0;
}

static int get_rwx(struct file *file, const char *buf)
{
	umode_t rwx;
	int result;

	if (sscanf(buf, "%hi", &rwx) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = check_perm(host);
		if (result == 0) {
			struct iattr newattrs;

			down(&host->i_sem);
			if (rwx == (mode_t) -1)
				rwx = host->i_mode;
			newattrs.ia_mode = 
				(rwx & S_IALLUGO) | (host->i_mode & ~S_IALLUGO);
			newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
			result = notify_change(file->f_dentry->d_parent, 
					       &newattrs);
			up(&host->i_sem);
		}
	} else
		result = RETERR(-EINVAL);
	return result;
}


static void * pseudos_start(struct seq_file *m, loff_t *pos)
{
	if (*pos >= LAST_PSEUDO_ID)
		return NULL;
	return pseudo_plugin_by_id(*pos);
}

static void pseudos_stop(struct seq_file *m, void *v)
{
}

static void * pseudos_next(struct seq_file *m, void *v, loff_t *pos)
{
	++ (*pos);
	return pseudos_start(m, pos);
}

static int pseudos_show(struct seq_file *m, void *v)
{
	pseudo_plugin *pplug;

	pplug = v;
	if (pplug->try != NULL)
		seq_printf(m, "%s\n", pplug->h.label);
	return 0;
}

static void * bmap_start(struct seq_file *m, loff_t *pos)
{
	struct inode *host;

	host = get_seq_pseudo_host(m);
	if (*pos << host->i_blkbits >= host->i_size)
		return NULL;
	else
		return (void *)((int)*pos + 1);
}

static void bmap_stop(struct seq_file *m, void *v)
{
}

static void * bmap_next(struct seq_file *m, void *v, loff_t *pos)
{
	++ (*pos);
	return bmap_start(m, pos);
}

extern sector_t reiser4_bmap(struct address_space *mapping, sector_t block);

static int bmap_show(struct seq_file *m, void *v)
{
	sector_t lblock;
	reiser4_block_nr sector;

	lblock = ((sector_t)(int)v) - 1;
	sector = reiser4_bmap(get_seq_pseudo_host(m)->i_mapping, lblock);
	if (sector >= 0) {
		if (blocknr_is_fake(&sector))
			seq_printf(m, "%#llx\n", sector);
		else
			seq_printf(m, "%llu\n", sector);
		return 0;
	} else
		return sector;
}

typedef struct readdir_cookie {
	tap_t       tap;
	coord_t     coord;
	lock_handle lh;
} readdir_cookie;

static int is_host_item(struct inode *host, coord_t *coord)
{
	if (item_type_by_coord(coord) != DIR_ENTRY_ITEM_TYPE)
		return 0;
	if (!inode_file_plugin(host)->owns_item(host, coord))
		return 0;
	return 1;
}

static void finish(struct inode *host, readdir_cookie *c)
{
	up(&host->i_sem);
	if (c != NULL) {
		tap_done(&c->tap);
		kfree(c);
	}
}

static void * readdir_start(struct seq_file *m, loff_t *pos)
{
	struct inode   *host;
	readdir_cookie *c;
	dir_plugin     *dplug;
	reiser4_key     dotkey;
	struct qstr     dotname;
	int             result;
	loff_t          entryno;


	host = get_seq_pseudo_host(m);
	dplug = inode_dir_plugin(host);

	dotname.name = ".";
	dotname.len  = 1;

	down(&host->i_sem);
	if (dplug == NULL) {
		finish(host, NULL);
		return NULL;
	}

	dplug->build_entry_key(host, &dotname, &dotkey);

	c = kmalloc(sizeof *c, GFP_KERNEL);
	if (c == NULL) {
		finish(host, NULL);
		return ERR_PTR(RETERR(-ENOMEM));
	}

	result = coord_by_key(tree_by_inode(host),
			      &dotkey,
			      &c->coord,
			      &c->lh,
			      ZNODE_READ_LOCK,
			      FIND_EXACT,
			      LEAF_LEVEL,
			      LEAF_LEVEL,
			      CBK_READDIR_RA,
			      NULL);

	tap_init(&c->tap, &c->coord, &c->lh, ZNODE_READ_LOCK);
	if (result == 0)
		result = tap_load(&c->tap); {
		if (result == 0) {
			for (entryno = 0; entryno != *pos; ++ entryno) {
				result = go_next_unit(&c->tap);
				if (result != 0)
					break;
				if (!is_host_item(host, c->tap.coord)) {
					finish(host, c);
					return NULL;
				}
			}
		}
	}
	if (result != 0) {
		finish(host, c);
		return ERR_PTR(result);
	}
	return c;
}

static void readdir_stop(struct seq_file *m, void *v)
{
}

static void * readdir_next(struct seq_file *m, void *v, loff_t *pos)
{
	readdir_cookie *c;
	struct inode   *host;
	int result;

	c = v;
	++ (*pos);
	host = get_seq_pseudo_host(m);
	result = go_next_unit(&c->tap);
	if (result == 0) {
		if (!is_host_item(host, c->tap.coord)) {
			finish(host, c);
			return NULL;
		} else
			return v;
	} else {
		finish(host, c);
		return ERR_PTR(result);
	}
}

static int readdir_show(struct seq_file *m, void *v)
{
	readdir_cookie *c;
	item_plugin *iplug;
	char *name;
	char buf[DE_NAME_BUF_LEN];

	c = v;
	iplug = item_plugin_by_coord(&c->coord);

	name = iplug->s.dir.extract_name(&c->coord, buf);
	assert("nikita-3221", name != NULL);
	seq_printf(m, "%s\n", name);
	return 0;
}

typedef struct plugin_entry {
	const char *name;
	int         offset;
} plugin_entry;

#define PLUGIN_ENTRY(field)			\
{						\
	.name = #field,				\
	.offset = offsetof(plugin_set, field)	\
}

static plugin_entry pentry[] = {
	PLUGIN_ENTRY(file),
	PLUGIN_ENTRY(dir),
	PLUGIN_ENTRY(perm),
	PLUGIN_ENTRY(tail),
	PLUGIN_ENTRY(hash),
	PLUGIN_ENTRY(sd),
	PLUGIN_ENTRY(dir_item),
	PLUGIN_ENTRY(crypto),
	PLUGIN_ENTRY(digest),
	PLUGIN_ENTRY(compression),
	{
		.name = NULL,
		.offset = 0
	}
};

typedef enum {
	PFIELD_TYPEID,
	PFIELD_ID,
	PFIELD_LABEL,
	PFIELD_DESC
} plugin_field;

static plugin_entry fentry[] = {
	{
		.name   = "type_id",
		.offset = PFIELD_TYPEID
	},
	{
		.name   = "id",
		.offset = PFIELD_ID
	},
	{
		.name   = "label",
		.offset = PFIELD_LABEL
	},
	{
		.name   = "desc",
		.offset = PFIELD_DESC
	},
	{
		.name   = NULL,
		.offset = 0
	},
};

static int show_plugin(struct seq_file *seq, void *cookie)
{
	struct inode   *host;
	struct file    *file;
	struct inode   *inode;
	reiser4_plugin *plug;
	plugin_entry   *entry;
	int             idx;
	plugin_set     *pset;

	file  = seq->private;
	inode = file->f_dentry->d_inode;

	/* foo is grandparent of foo/..plugin/file  */
	host  = get_inode_host(get_inode_host(inode));
	idx   = reiser4_inode_data(inode)->file_plugin_data.pseudo_info.datum;
	entry = &pentry[idx];
	pset  = reiser4_inode_data(host)->pset;
	plug  = *(reiser4_plugin **)(((char *)pset) + entry->offset);

	if (plug != NULL)
		seq_printf(seq, "%i %s %s",
			   plug->h.id, plug->h.label, plug->h.desc);
	return 0;
}

static int lookup_plugin_field(struct inode *parent, struct dentry * dentry)
{
	int result;
	int idx;
	struct inode *pseudo;

	pseudo_plugin *pplug;

	pseudo = ERR_PTR(-ENOENT);
	pplug  = pseudo_plugin_by_id(PSEUDO_PLUGIN_FIELD_ID);
	for (idx = 0; fentry[idx].name != NULL; ++ idx) {
		if (!strcmp(dentry->d_name.name, fentry[idx].name)) {

			pseudo = add_pseudo(parent, pplug, dentry);
			break;
		}
	}
	if (IS_ERR(pseudo))
		result = PTR_ERR(pseudo);
	else {
		result = 0;
		pseudo_set_datum(pseudo, idx);
	}
	return result;
}

static int show_plugin_field(struct seq_file *seq, void *cookie)
{
	struct inode   *host;
	struct inode   *parent;
	struct file    *file;
	struct inode   *inode;
	reiser4_plugin *plug;
	plugin_entry   *entry;
	int             pidx;
	int             idx;
	plugin_set     *pset;

	file  = seq->private;
	inode = file->f_dentry->d_inode;

	parent = get_inode_host(inode);
	/* foo is grand-grand-parent of foo/..plugin/hash/id  */
	host  = get_inode_host(get_inode_host(parent));
	pidx  = reiser4_inode_data(parent)->file_plugin_data.pseudo_info.datum;
	idx   = reiser4_inode_data(inode)->file_plugin_data.pseudo_info.datum;
	entry = &pentry[pidx];
	pset  = reiser4_inode_data(host)->pset;
	plug  = *(reiser4_plugin **)(((char *)pset) + entry->offset);

	if (plug != NULL) {
	switch (fentry[idx].offset) {
	case PFIELD_TYPEID:
		seq_printf(seq, "%i", plug->h.type_id);
		break;
	case PFIELD_ID:
		seq_printf(seq, "%i", plug->h.id);
		break;
	case PFIELD_LABEL:
		seq_printf(seq, "%s", plug->h.label);
		break;
	case PFIELD_DESC:
		seq_printf(seq, "%s", plug->h.desc);
		break;
	}
	}

	return 0;
}

static int readdir_plugin_field(struct file *f, void *dirent, filldir_t filld)
{
	loff_t off;
	for (off = f->f_pos; off < sizeof_array(fentry) - 1; ++ off) {
		const char *name;

		name = fentry[off].name;

		if (filld(dirent, name, strlen(name), off, off + 10, DT_REG) < 0)
			break;
	}
	f->f_pos = off;
	return 0;
}

static int lookup_plugins(struct inode *parent, struct dentry * dentry)
{
	int result;
	int idx;
	struct inode *pseudo;

	pseudo_plugin *pplug;

	pseudo = ERR_PTR(-ENOENT);
	pplug  = pseudo_plugin_by_id(PSEUDO_PLUGIN_ID);
	for (idx = 0; pentry[idx].name != NULL; ++ idx) {
		if (!strcmp(dentry->d_name.name, pentry[idx].name)) {

			pseudo = add_pseudo(parent, pplug, dentry);
			break;
		}
	}
	if (IS_ERR(pseudo))
		result = PTR_ERR(pseudo);
	else {
		pseudo_set_datum(pseudo, idx);
		result = 0;
	}
	return result;
}

static int readdir_plugins(struct file *f, void *dirent, filldir_t filld)
{
	loff_t off;
	for (off = f->f_pos; off < sizeof_array(pentry) - 1; ++ off) {
		const char *name;

		name = pentry[off].name;

		if (filld(dirent, name, strlen(name), off, off + 10, DT_REG) < 0)
			break;
	}
	f->f_pos = off;
	return 0;
}


pseudo_plugin pseudo_plugins[LAST_PSEUDO_ID] = {
	[PSEUDO_UID_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_UID_ID,
			       .pops = NULL,
			       .label = "..uid",
			       .desc = "returns owner",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_uid
			 },
			 .write_type  = PSEUDO_WRITE_STRING,
			 .write       = {
				 .gets        = get_uid
			 }
	},
	[PSEUDO_GID_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_GID_ID,
			       .pops = NULL,
			       .label = "..gid",
			       .desc = "returns group",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_gid
			 },
			 .write_type  = PSEUDO_WRITE_STRING,
			 .write       = {
				 .gets        = get_gid
			 }
	},
	[PSEUDO_RWX_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_RWX_ID,
			       .pops = NULL,
			       .label = "..rwx",
			       .desc = "returns rwx permissions",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_rwx
			 },
			 .write_type  = PSEUDO_WRITE_STRING,
			 .write       = {
				 .gets        = get_rwx
			 }
	},
	[PSEUDO_OID_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_OID_ID,
			       .pops = NULL,
			       .label = "..oid",
			       .desc = "returns object id",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_oid
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_KEY_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_KEY_ID,
			       .pops = NULL,
			       .label = "..key",
			       .desc = "returns object's key",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_key
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_SIZE_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_SIZE_ID,
			       .pops = NULL,
			       .label = "..size",
			       .desc = "returns object's size",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_size
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_NLINK_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_NLINK_ID,
			       .pops = NULL,
			       .label = "..nlink",
			       .desc = "returns nlink count",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_nlink
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_LOCALITY_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_LOCALITY_ID,
			       .pops = NULL,
			       .label = "..locality",
			       .desc = "returns object's locality",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_locality
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_PSEUDOS_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_PSEUDOS_ID,
			       .pops = NULL,
			       .label = "..pseudo",
			       .desc = "returns a list of pseudo files",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SEQ,
			 .read        = {
				 .ops = {
					 .start = pseudos_start,
					 .stop  = pseudos_stop,
					 .next  = pseudos_next,
					 .show  = pseudos_show
				 }
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_BMAP_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_BMAP_ID,
			       .pops = NULL,
			       .label = "..bmap",
			       .desc = "returns a list blocks for this file",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SEQ,
			 .read        = {
				 .ops = {
					 .start = bmap_start,
					 .stop  = bmap_stop,
					 .next  = bmap_next,
					 .show  = bmap_show
				 }
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_READDIR_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_READDIR_ID,
			       .pops = NULL,
			       .label = "..readdir",
			       .desc = "returns a list of names in the dir",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SEQ,
			 .read        = {
				 .ops = {
					 .start = readdir_start,
					 .stop  = readdir_stop,
					 .next  = readdir_next,
					 .show  = readdir_show
				 }
			 },
			 .write_type  = PSEUDO_WRITE_NONE
	},
	[PSEUDO_PLUGIN_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_PLUGIN_ID,
			       .pops = NULL,
			       .label = "plugin",
			       .desc = "plugin",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = NULL,
			 .lookup      = lookup_plugin_field,
			 .lookup_mode = S_IFREG | S_IRUGO | S_IXUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_plugin
			 },
			 .write_type  = PSEUDO_WRITE_NONE,
			 .readdir     = readdir_plugin_field
	},
	[PSEUDO_PLUGINS_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_PLUGINS_ID,
			       .pops = NULL,
			       .label = "..plugin",
			       .desc = "list of plugins",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = try_by_label,
			 .lookup      = lookup_plugins,
			 .lookup_mode = S_IFREG | S_IRUGO | S_IXUGO,
			 .read_type   = PSEUDO_READ_NONE,
			 .write_type  = PSEUDO_WRITE_NONE,
			 .readdir     = readdir_plugins
	},
	[PSEUDO_PLUGIN_FIELD_ID] = {
			 .h = {
			       .type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			       .id = PSEUDO_PLUGIN_ID,
			       .pops = NULL,
			       .label = "plugin",
			       .desc = "plugin",
			       .linkage = TS_LIST_LINK_ZERO
			 },
			 .try         = NULL,
			 .lookup      = NULL,
			 .lookup_mode = S_IFREG | S_IRUGO,
			 .read_type   = PSEUDO_READ_SINGLE,
			 .read        = {
				 .single_show = show_plugin_field
			 },
			 .write_type  = PSEUDO_WRITE_NONE,
			 .readdir     = NULL
	}
};

/* Make Linus happy.
   Local variables:
   c-indentation-style: "K&R"
   mode-name: "LC"
   c-basic-offset: 8
   tab-width: 8
   fill-column: 120
   scroll-step: 1
   End:
*/
