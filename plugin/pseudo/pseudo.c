/* Copyright 2001, 2002, 2003 by Hans Reiser, licensing governed by
 * reiser4/README */

/* Handling of "pseudo" files representing unified access to meta data in
   reiser4. */

/*
 * See http://namesys.com/v4/v4.html, and especially
 * http://namesys.com/v4/pseudo.html for basic information about reiser4
 * pseudo files, access to meta-data, reiser4() system call, etc.
 *
 * Pseudo files should be accessible from both reiser4() system call and
 * normal POSIX calls.
 *
 * OVERVIEW
 *
 *     Pseudo files provide access to various functionality through file
 *     system name space. As such they are similar to pseudo file systems
 *     already existing in UNIX and Linux: procfs, sysfs, etc. But pseudo
 *     files are embedded into name space of Reiser4---real block device based
 *     file system, and are more tightly integrated with it. In particular,
 *     some pseudo files are "attached" to other files (either "real" or also
 *     pseudo), by being accessible through path names of the form
 *
 *         "a/b/c/something"
 *
 *     Here object accessible through "a/b/c/something" is attached to the
 *     object accessible through "a/b/c" , and the latter is said to be the
 *     "host" object of the former.
 *
 *     Object can have multiple pseudo files attached to it, distinguished by
 *     the last component of their names "something", "somethingelse",
 *     etc.
 *
 *     (Note however, that currently "real" files have only one single pseudo
 *     file attached to them, viz. pseudo directory "....". This directory in
 *     turn contains all other pseudo files pertaining to the real file that
 *     "...." is attached to. To avoid referencing "...." all the time
 *     "a/b/c" is called a host of "/a/b/c/..../something". This violates
 *     definition above, but is convenient.)
 *
 *     Moreover, in addition to the purely pseudo files (that is, file system
 *     objects whose content (as available through read(2) system call) is not
 *     backed by any kind of persistent storage), extended file attributes
 *     (see attr(5) on Linux, and http://acl.bestbits.at/) including security
 *     attributes such as ACLs are also available through file system name
 *     space.
 *
 *     As a result each file system object has a sub-name-space rooted at it,
 *     which is in striking contrast with traditional UNIX file system, where
 *     only directories has sub-objects and all other types of files (regular,
 *     FIFO-s, devices, and symlinks) are leaves.
 *
 *     For the sake of objectivity it should be mentioned that this is not
 *     _completely_ new development in file system design, see
 *     http://docs.sun.com/db/doc/816-0220/6m6nkorp9?a=view
 *
 *     In particular, as each object has sub-objects, name space tree is
 *     infinite in both extent (number of reachable objects) and depth.
 *
 *     Some pseudo files are "built-in". They are present as sub-objects in
 *     each file system object, unless specifically disabled.
 *
 *     Built-in pseudo files are implemented in this file and described at
 *     http://namesys.com/v4/pseudo.html
 *
 * IMPLEMENTATION
 *
 *     Pseudo files are implemented as normal inodes, living in the same super
 *     block as other inodes for reiser4 file system. Their inode numbers are
 *     generated by fs/inode.c:new_inode() function and are not persistent (in
 *     the sense that they are not guaranteed to be the same after
 *     remount). To avoid clashes with "normal" inodes, all pseudo inodes are
 *     placed into otherwise unused locality (for example, 0), hence allowing
 *     reiser4_inode_find_actor() to tell them from normal inodes.
 *
 *     All pseudo inodes share the same object plugin
 *     PSEUDO_FILE_PLUGIN_ID. In pseudo-inode specific part of reiser4_inode
 *     (pseudo_info), two things are stored:
 *
 *         1. pointer to the inode of the "host object" (for /a/b/c/..../acl,
 *         /a/b/c is the host object)
 *
 *         2. pointer to pseudo plugin, used by PSEUDO_FILE_PLUGIN_ID to
 *         implement VFS operations.
 *
 *     This design has following advantages:
 *
 *         1. provides for ease addition of new pseudo files without going
 *         through writing whole new object plugin.
 *
 *         2. allows sys_reiser4() to be implemented by directory invoking
 *         pseudo plugin methods.
 *
 */

#include "../../inode.h"
#include "../../debug.h"
#include "../plugin.h"

#include "pseudo.h"

static int init_pseudo(struct inode *parent, struct inode *pseudo,
		       pseudo_plugin * pplug, const char *name);

static struct inode *add_pseudo(struct inode *parent,
				pseudo_plugin * pplug, struct dentry **d);

/*
 * helper method: set ->datum field in the pseudo file specific portion of
 * reiser4 inode.
 */
static void pseudo_set_datum(struct inode *pseudo, unsigned long datum)
{
	reiser4_inode_data(pseudo)->file_plugin_data.pseudo_info.datum = datum;
}

/*
 * return id of pseudo file plugin for this inode @p
 */
static int pseudo_id(struct inode *p)
{
	return reiser4_inode_data(p)->file_plugin_data.pseudo_info.plugin->h.id;
}

/*
 * helper method used to implement ->lookup() method of pseudo files.
 *
 * Try to find a pseudo plugin that matches given name (stored in @dentry) and
 * has ->parent field equal to @id.
 *
 * Convention is that ->parent field is set to the id of the pseudo plugin of
 * the parent pseudo file in the hierarchy (that is, plugin for
 * "a/..../foo/bar" has ->parent set to the plugin id of "a/..../foo"), with
 * the exception of "a/...." that uses special reserved value TOP_LEVEL for
 * ->parent.
 */
static int
lookup_of_plugin(struct inode *parent, int id, struct dentry **dentry)
{
	const char *name;
	struct inode *pseudo;
	reiser4_plugin *plugin;
	int result;

	name = (*dentry)->d_name.name;
	pseudo = ERR_PTR(-ENOENT);

	/* scan all pseudo file plugins and check each */
	for_all_plugins(REISER4_PSEUDO_PLUGIN_TYPE, plugin) {
		pseudo_plugin *pplug;

		pplug = &plugin->pseudo;
		if (pplug->parent == id &&
		    pplug->try != NULL && pplug->try(pplug, parent, name)) {
			pseudo = add_pseudo(parent, pplug, dentry);
			break;
		}
	}
	if (!IS_ERR(pseudo))
		result = 0;
	else
		result = PTR_ERR(pseudo);
	return result;
}

/*
 * implement ->lookup() method using convention described in the comment for
 * lookup_of_plugin() function.
 */
static int lookup_table(struct inode *parent, struct dentry **dentry)
{
	assert("nikita-3511", parent != NULL);
	assert("nikita-3512", dentry != NULL);
	assert("nikita-3513",
	       inode_file_plugin(parent)->h.id == PSEUDO_FILE_PLUGIN_ID);

	/*
	 * call lookup_of_plugin() passing id of pseudo plugin for @parent as
	 * "id" parameter.
	 */
	return lookup_of_plugin(parent, pseudo_id(parent), dentry);
}

/*
 * helper to implement ->readdir() method for the pseudo files. It uses the
 * same convention as lookup_of_plugin() function.
 */
static int readdir_table(struct file *f, void *dirent, filldir_t filld)
{
	loff_t off;
	ino_t ino;
	int skip;
	int id;

	struct inode *inode;
	reiser4_plugin *plugin;

	off = f->f_pos;
	if (off < 0)
		return 0;

	inode = f->f_dentry->d_inode;
	switch ((int)off) {
		/*
		 * first, return dot and dotdot
		 */
	case 0:
		ino = inode->i_ino;
		if (filld(dirent, ".", 1, off, ino, DT_DIR) < 0)
			break;
		++off;
		/* fallthrough */
	case 1:
		ino = parent_ino(f->f_dentry);
		if (filld(dirent, "..", 2, off, ino, DT_DIR) < 0)
			break;
		++off;
		/* fallthrough */
	default:
		skip = off - 2;
		id = pseudo_id(inode);
		/* then, scan all pseudo plugins, looking for the ones with
		 * matching ->parent */
		for_all_plugins(REISER4_PSEUDO_PLUGIN_TYPE, plugin) {
			pseudo_plugin *pplug;
			const char *name;

			pplug = &plugin->pseudo;
			if (pplug->parent == id && pplug->readdirable) {
				if (skip == 0) {
					name = pplug->h.label;
					/*
					 * if match is found---fed @filld with
					 * it
					 */
					if (filld(dirent, name, strlen(name),
						  off,
						  off + (long)f, DT_REG) < 0)
						break;
					++off;
				} else
					--skip;
			}
		}
	}
	f->f_pos = off;
	return 0;
}

/*
 * special value of ->parent field in pseudo file plugin used by "...." top
 * level pseudo directory.
 */
#define TOP_LEVEL (-1)

/*
 * try to look up built-in pseudo file by its name.
 */
int lookup_pseudo_file(struct inode *parent, struct dentry **dentry)
{
	assert("nikita-2999", parent != NULL);
	assert("nikita-3000", dentry != NULL);

#if !ENABLE_REISER4_PSEUDO
	return RETERR(-ENOENT);
#endif				/* ENABLE_REISER4_PSEUDO */
	/* if pseudo files are disabled for this file system bail out */
	if (reiser4_is_set(parent->i_sb, REISER4_NO_PSEUDO))
		return RETERR(-ENOENT);
	else
		return lookup_of_plugin(parent, TOP_LEVEL, dentry);
}

/* create inode for pseudo file with plugin @pplug, and add it to the @parent
 * under name @d */
static struct inode *add_pseudo(struct inode *parent,
				pseudo_plugin * pplug, struct dentry **d)
{
	struct inode *pseudo;

	pseudo = new_inode(parent->i_sb);
	if (pseudo != NULL) {
		int result;

		result = init_pseudo(parent, pseudo, pplug, (*d)->d_name.name);
		if (result != 0)
			pseudo = ERR_PTR(result);
		else
			*d = d_splice_alias(pseudo, *d);
	} else
		pseudo = ERR_PTR(RETERR(-ENOMEM));
	return pseudo;
}

/* helper function: return host object of @inode pseudo file */
static struct inode *get_inode_host(struct inode *inode)
{
	assert("nikita-3510",
	       inode_file_plugin(inode)->h.id == PSEUDO_FILE_PLUGIN_ID);
	return reiser4_inode_data(inode)->file_plugin_data.pseudo_info.host;
}

/* helper function: return parent object of @inode pseudo file */
static struct inode *get_inode_parent(struct inode *inode)
{
	assert("nikita-3510",
	       inode_file_plugin(inode)->h.id == PSEUDO_FILE_PLUGIN_ID);
	return reiser4_inode_data(inode)->file_plugin_data.pseudo_info.parent;
}

/*
 * initialize pseudo file @pseudo to be child of @parent, with plugin @pplug
 * and name @name.
 */
static int
init_pseudo(struct inode *parent, struct inode *pseudo,
	    pseudo_plugin * pplug, const char *name)
{
	int result;
	struct inode *host;
	reiser4_inode *idata;
	reiser4_object_create_data data;
	static const oid_t pseudo_locality = 0x0ull;

	idata = reiser4_inode_data(pseudo);
	/* all pseudo files live in special reserved locality */
	idata->locality_id = pseudo_locality;

	/*
	 * setup ->parent and ->host fields
	 */
	if (pplug->parent != TOP_LEVEL)
		/* host of "a/..../b/c" is "a" */
		host = get_inode_host(parent);
	else
		/* host of "a/...." is "a" */
		host = parent;

	idata->file_plugin_data.pseudo_info.host = host;
	idata->file_plugin_data.pseudo_info.parent = parent;
	idata->file_plugin_data.pseudo_info.plugin = pplug;

	data.id = PSEUDO_FILE_PLUGIN_ID;
	data.mode = pplug->lookup_mode;

	plugin_set_file(&idata->pset, file_plugin_by_id(PSEUDO_FILE_PLUGIN_ID));
	/* if plugin has a ->lookup method, it means that @pseudo should
	 * behave like directory. */
	if (pplug->lookup != NULL)
		plugin_set_dir(&idata->pset,
			       dir_plugin_by_id(PSEUDO_DIR_PLUGIN_ID));

	/* perform standard plugin initialization */
	result = inode_file_plugin(pseudo)->set_plug_in_inode(pseudo,
							      parent, &data);
	if (result != 0) {
		warning("nikita-3203", "Cannot install pseudo plugin");
		return result;
	}

	/* inherit permission plugin from parent, */
	grab_plugin(pseudo, parent, PSET_PERM);
	/* and credentials... */
	pseudo->i_uid = parent->i_uid;
	pseudo->i_gid = parent->i_gid;

	pseudo->i_nlink = 1;
	/* insert inode into VFS hash table */
	insert_inode_hash(pseudo);
	return 0;
}

/* helper function: return host object by file descriptor */
static struct inode *get_pseudo_host(struct file *file)
{
	struct inode *inode;

	inode = file->f_dentry->d_inode;
	return get_inode_host(inode);
}

/* helper function: return host object by seq_file */
static struct inode *get_seq_pseudo_host(struct seq_file *seq)
{
	struct file *file;

	file = seq->private;
	return get_pseudo_host(file);
}

/*
 * implementation of ->try method for pseudo files with fixed names.
 */
static int try_by_label(pseudo_plugin * pplug,
			const struct inode *parent, const char *name)
{
	return !strcmp(name, pplug->h.label);
}

/*
 * read method for the "..../uid" pseudo file.
 */
static int show_uid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lu", (long unsigned)get_seq_pseudo_host(seq)->i_uid);
	return 0;
}

/* helper: check permissions required to modify ..../[ug]id */
static int check_perm(struct inode *inode)
{
	if (IS_RDONLY(inode))
		return RETERR(-EROFS);
	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
		return RETERR(-EPERM);
	return 0;
}

/*
 * helper function to update [ug]id of @inode. Called by "..../[ug]id" write
 * methods
 */
static int update_ugid(struct dentry *dentry, struct inode *inode,
		       uid_t uid, gid_t gid)
{
	int result;

	/* logic COPIED from fs/open.c:chown_common() */
	result = check_perm(inode);
	if (result == 0) {
		struct iattr newattrs;

		newattrs.ia_valid = ATTR_CTIME;
		if (uid != (uid_t) - 1) {
			newattrs.ia_valid |= ATTR_UID;
			newattrs.ia_uid = uid;
		}
		if (gid != (uid_t) - 1) {
			newattrs.ia_valid |= ATTR_GID;
			newattrs.ia_gid = gid;
		}
		if (!S_ISDIR(inode->i_mode))
			newattrs.ia_valid |= ATTR_KILL_SUID | ATTR_KILL_SGID;
		down(&inode->i_sem);
		result = notify_change(dentry, &newattrs);
		up(&inode->i_sem);
	}
	return result;
}

/*
 * write method for the "..../uid": extract uid from user-supplied buffer,
 * and update uid
 */
static int store_uid(struct file *file, const char *buf)
{
	uid_t uid;
	int result;

	if (sscanf(buf, "%i", &uid) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = update_ugid(file->f_dentry->d_parent->d_parent,
				     host, uid, -1);
	} else
		result = RETERR(-EINVAL);
	return result;
}

/*
 * read method for the "..../uid" pseudo file.
 */
static int show_gid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lu", (long unsigned)get_seq_pseudo_host(seq)->i_gid);
	return 0;
}

/*
 * write method for the "..../gid": extract uid from user-supplied buffer,
 * and update gid
 */
static int get_gid(struct file *file, const char *buf)
{
	gid_t gid;
	int result;

	if (sscanf(buf, "%i", &gid) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = update_ugid(file->f_dentry->d_parent->d_parent,
				     host, -1, gid);
	} else
		result = RETERR(-EINVAL);
	return result;
}

/*
 * read method for the "..../oid" pseudo file
 */
static int show_oid(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%llu",
		   (unsigned long long)get_inode_oid(get_seq_pseudo_host(seq)));
	return 0;
}

/*
 * read method for the "..../key" pseudo file
 */
static int show_key(struct seq_file *seq, void *cookie)
{
	char buf[KEY_BUF_LEN];
	reiser4_key key;

	sprintf_key(buf, build_sd_key(get_seq_pseudo_host(seq), &key));
	seq_printf(seq, "%s", buf);
	return 0;
}

/*
 * read method for the "..../size" pseudo file
 */
static int show_size(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%lli", get_seq_pseudo_host(seq)->i_size);
	return 0;
}

/*
 * read method for the "..../nlink" pseudo file
 */
static int show_nlink(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%u", get_seq_pseudo_host(seq)->i_nlink);
	return 0;
}

/*
 * read method for the "..../locality" pseudo file
 */
static int show_locality(struct seq_file *seq, void *cookie)
{
	seq_printf(seq, "%llu",
		   (unsigned long long)
		   reiser4_inode_data(get_seq_pseudo_host(seq))->locality_id);
	return 0;
}

/*
 * read method for the "..../rwx" pseudo file
 */
static int show_rwx(struct seq_file *seq, void *cookie)
{
	umode_t m;

	m = get_seq_pseudo_host(seq)->i_mode;
	seq_printf(seq, "%#ho %c%c%c%c%c%c%c%c%c%c",
		   m,
		   S_ISREG(m) ? '-' :
		   S_ISDIR(m) ? 'd' :
		   S_ISCHR(m) ? 'c' :
		   S_ISBLK(m) ? 'b' :
		   S_ISFIFO(m) ? 'p' :
		   S_ISLNK(m) ? 'l' :
		   S_ISSOCK(m) ? 's' : '?',
		   m & S_IRUSR ? 'r' : '-',
		   m & S_IWUSR ? 'w' : '-',
		   m & S_IXUSR ? 'x' : '-',
		   m & S_IRGRP ? 'r' : '-',
		   m & S_IWGRP ? 'w' : '-',
		   m & S_IXGRP ? 'x' : '-',
		   m & S_IROTH ? 'r' : '-',
		   m & S_IWOTH ? 'w' : '-', m & S_IXOTH ? 'x' : '-');
	return 0;
}

/*
 * write method for the "..../rwx" file. Extract permission bits from the
 * user supplied buffer and update ->i_mode.
 */
static int get_rwx(struct file *file, const char *buf)
{
	umode_t rwx;
	int result;

	if (sscanf(buf, "%hi", &rwx) == 1) {
		struct inode *host;

		host = get_pseudo_host(file);
		result = check_perm(host);
		if (result == 0) {
			struct iattr newattrs;

			down(&host->i_sem);
			if (rwx == (umode_t) ~ 0)
				rwx = host->i_mode;
			newattrs.ia_mode =
			    (rwx & S_IALLUGO) | (host->i_mode & ~S_IALLUGO);
			newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
			result =
			    notify_change(file->f_dentry->d_parent->d_parent,
					  &newattrs);
			up(&host->i_sem);
		}
	} else
		result = RETERR(-EINVAL);
	return result;
}

/*
 * seq-methods for "..../pseudo"
 */

/*
 * start iteration over all pseudo files
 */
static void *pseudos_start(struct seq_file *m, loff_t * pos)
{
	if (*pos >= LAST_PSEUDO_ID)
		return NULL;
	return pseudo_plugin_by_id(*pos);
}

/*
 * stop iteration over all pseudo files
 */
static void pseudos_stop(struct seq_file *m, void *v)
{
}

/*
 * go to next pseudo file in the sequence
 */
static void *pseudos_next(struct seq_file *m, void *v, loff_t * pos)
{
	++(*pos);
	return pseudos_start(m, pos);
}

/*
 * output information about particular pseudo file.
 */
static int pseudos_show(struct seq_file *m, void *v)
{
	pseudo_plugin *pplug;

	pplug = v;
	if (pplug->try != NULL)
		seq_printf(m, "%s\n", pplug->h.label);
	return 0;
}

/*
 * seq-methods for "..../bmap"
 */

/*
 * start iteration over all blocks allocated for the host file
 */
static void *bmap_start(struct seq_file *m, loff_t * pos)
{
	struct inode *host;

	host = get_seq_pseudo_host(m);
	if (*pos << host->i_blkbits >= host->i_size)
		return NULL;
	else
		return (void *)((unsigned long)*pos + 1);
}

/*
 * stop iteration over all blocks allocated for the host file
 */
static void bmap_stop(struct seq_file *m, void *v)
{
}

/*
 * go to the next block in the sequence of blocks allocated for the host
 * file.
 */
static void *bmap_next(struct seq_file *m, void *v, loff_t * pos)
{
	++(*pos);
	return bmap_start(m, pos);
}

/*
 * output information about single block number allocated for the host file
 * into user supplied buffer
 */
static int bmap_show(struct seq_file *m, void *v)
{
	sector_t lblock, block;
	reiser4_block_nr blocknr;

	lblock = ((sector_t) (unsigned long)v) - 1;
	block =
	    get_seq_pseudo_host(m)->i_mapping->a_ops->
	    bmap(get_seq_pseudo_host(m)->i_mapping, lblock);
	if (block > 0) {
		if (blocknr_is_fake(&blocknr))
			seq_printf(m, "%#llx\n", (unsigned long long)blocknr);
		else
			seq_printf(m, "%llu\n", (unsigned long long)blocknr);
	}
	return 0;
}

/*
 * seq-methods for the "..../readdir"
 */

/* "cursor" used to iterate over all directory entries for the host file */
typedef struct readdir_cookie {
	/* position within the tree */
	tap_t tap;
	/* coord used by ->tap */
	coord_t coord;
	/* lock handle used by ->tap */
	lock_handle lh;
} readdir_cookie;

/* true if @coord stores directory entries for @host */
static int is_host_item(struct inode *host, coord_t * coord)
{
	if (item_type_by_coord(coord) != DIR_ENTRY_ITEM_TYPE)
		return 0;
	if (!inode_file_plugin(host)->owns_item(host, coord))
		return 0;
	return 1;
}

/* helper function to release resources allocated to iterate over directory
 * entries for the host file */
static void finish(readdir_cookie * c)
{
	if (c != NULL && !IS_ERR(c)) {
		/* release c->tap->lh long term lock... */
		tap_done(&c->tap);
		/* ... and free cursor itself */
		kfree(c);
	}
}

/*
 * start iterating over directory entries for the host file
 */
static void *readdir_start(struct seq_file *m, loff_t * pos)
{
	struct inode *host;
	readdir_cookie *c;
	dir_plugin *dplug;
	reiser4_key dotkey;
	struct qstr dotname;
	int result;
	loff_t entryno;

	/*
	 * first, lookup item containing dot of the host
	 */

	host = get_seq_pseudo_host(m);
	dplug = inode_dir_plugin(host);

	dotname.name = ".";
	dotname.len = 1;

	down(&host->i_sem);
	if (dplug == NULL || dplug->build_entry_key == NULL) {
		finish(NULL);
		return NULL;
	}

	/* build key of dot */
	dplug->build_entry_key(host, &dotname, &dotkey);

	/* allocate cursor */
	c = kmalloc(sizeof *c, GFP_KERNEL);
	if (c == NULL) {
		finish(NULL);
		return ERR_PTR(RETERR(-ENOMEM));
	}

	/* tree lookup */
	result = object_lookup(host,
			       &dotkey,
			       &c->coord,
			       &c->lh,
			       ZNODE_READ_LOCK,
			       FIND_EXACT,
			       LEAF_LEVEL, LEAF_LEVEL, CBK_READDIR_RA, NULL);

	tap_init(&c->tap, &c->coord, &c->lh, ZNODE_READ_LOCK);
	if (result == 0)
		/*
		 * ok, now c->tap is positioned at the dot. We are requested
		 * to start readdir from the offset *pos. Skip that number of
		 * entries. That's not very efficient for the large
		 * directories.
		 */
		result = tap_load(&c->tap); {
		if (result == 0) {
			for (entryno = 0; entryno != *pos; ++entryno) {
				result = go_next_unit(&c->tap);
				if (result == -E_NO_NEIGHBOR) {
					finish(c);
					return NULL;
				}
				if (result != 0)
					break;
				if (!is_host_item(host, c->tap.coord)) {
					finish(c);
					return NULL;
				}
			}
		}
		}
		if (result != 0) {
			finish(c);
			return ERR_PTR(result);
		} else
			return c;
}

/*
 * stop iterating over directory entries for the host file
 */
static void readdir_stop(struct seq_file *m, void *v)
{
	up(&get_seq_pseudo_host(m)->i_sem);
	finish(v);
}

/*
 * go to the next entry in the host directory
 */
static void *readdir_next(struct seq_file *m, void *v, loff_t * pos)
{
	readdir_cookie *c;
	struct inode *host;
	int result;

	c = v;
	++(*pos);
	host = get_seq_pseudo_host(m);
	/* next entry is in the next unit */
	result = go_next_unit(&c->tap);
	if (result == 0) {
		/* check whether end of the directory was reached. */
		if (!is_host_item(host, c->tap.coord)) {
			finish(c);
			return NULL;
		} else
			return v;
	} else {
		finish(c);
		return ERR_PTR(result);
	}
}

/*
 * output information about single directory entry in the host directory
 */
static int readdir_show(struct seq_file *m, void *v)
{
	readdir_cookie *c;
	item_plugin *iplug;
	char *name;
	char buf[DE_NAME_BUF_LEN];

	c = v;
	iplug = item_plugin_by_coord(&c->coord);

	name = iplug->s.dir.extract_name(&c->coord, buf);
	assert("nikita-3221", name != NULL);
	/* entries are separated by the "/" in the user buffer, because this
	 * is the only symbol (besides NUL) that is not allowed in file
	 * names. */
	seq_printf(m, "%s/", name);
	return 0;
}

/*
 * methods for "..../plugin"
 */

/*
 * entry in the table mapping plugin pseudo file name to the corresponding
 * pset member.
 */
typedef struct plugin_entry {
	const char *name;
	pset_member memb;
} plugin_entry;

/* initializer for plugin_entry */
#define PLUGIN_ENTRY(field, ind)		\
{						\
	.name = #field,				\
	.memb = ind				\
}

#define PSEUDO_ARRAY_ENTRY(idx, aname)		\
[idx] = {					\
	.name = aname				\
}

/*
 * initialize array defining files available under "..../plugin".
 */
static plugin_entry pentry[] = {
	/* "a/..../plugin/file" corresponds to the PSET_FILE plugin of its
	 * host file (that is, "a"), etc. */
	PLUGIN_ENTRY(file, PSET_FILE),
	PLUGIN_ENTRY(dir, PSET_DIR),
	PLUGIN_ENTRY(perm, PSET_PERM),
	PLUGIN_ENTRY(formatting, PSET_FORMATTING),
	PLUGIN_ENTRY(hash, PSET_HASH),
	PLUGIN_ENTRY(fibration, PSET_FIBRATION),
	PLUGIN_ENTRY(sd, PSET_SD),
	PLUGIN_ENTRY(dir_item, PSET_DIR_ITEM),
	PLUGIN_ENTRY(crypto, PSET_CRYPTO),
	PLUGIN_ENTRY(digest, PSET_DIGEST),
	PLUGIN_ENTRY(compression, PSET_COMPRESSION),
	PLUGIN_ENTRY(compression_mode, PSET_COMPRESSION_MODE),
	PLUGIN_ENTRY(cluster, PSET_CLUSTER),
	PLUGIN_ENTRY(regular, PSET_REGULAR_ENTRY),
	{
	 .name = NULL,
	 }
};

/*
 * enumeration of files available under "a/..../plugin/foo"
 */
typedef enum {
	PFIELD_TYPEID,		/* "a/..../plugin/foo/type_id" contains type id of the
				 * plugin foo */
	PFIELD_ID,		/* "a/..../plugin/foo/id" contains id of the plugin
				 * foo */
	PFIELD_LABEL,		/* "a/..../plugin/foo/label" contains label of the
				 * plugin foo */
	PFIELD_DESC		/* "a/..../plugin/foo/desc" contains description of
				 * the plugin foo */
} plugin_field;

/* map pseudo files under "a/..../plugin/foo" to their names */
static plugin_entry fentry[] = {
	PSEUDO_ARRAY_ENTRY(PFIELD_TYPEID, "type_id"),
	PSEUDO_ARRAY_ENTRY(PFIELD_ID, "id"),
	PSEUDO_ARRAY_ENTRY(PFIELD_LABEL, "label"),
	PSEUDO_ARRAY_ENTRY(PFIELD_DESC, "desc"),
	{
	 .name = NULL},
};

/* read method for "a/..../plugin/foo" */
static int show_plugin(struct seq_file *seq, void *cookie)
{
	struct inode *host;
	struct file *file;
	struct inode *inode;
	reiser4_plugin *plug;
	plugin_entry *entry;
	int idx;
	plugin_set *pset;

	file = seq->private;
	inode = file->f_dentry->d_inode;

	host = get_inode_host(inode);
	idx = reiser4_inode_data(inode)->file_plugin_data.pseudo_info.datum;
	entry = &pentry[idx];
	pset = reiser4_inode_data(host)->pset;
	plug = pset_get(pset, entry->memb);

	if (plug != NULL)
		seq_printf(seq, "%i %s %s",
			   plug->h.id, plug->h.label, plug->h.desc);
	return 0;
}

/*
 * write method for "a/..../plugin/foo": extract plugin label from the user
 * supplied buffer @buf and update plugin foo, if possible.
 */
static int set_plugin(struct file *file, const char *buf)
{
	struct inode *host;
	struct inode *inode;
	reiser4_plugin *plug;
	plugin_entry *entry;
	int idx;
	plugin_set *pset;
	int result;
	reiser4_context *ctx;

	inode = file->f_dentry->d_inode;
	ctx = init_context(inode->i_sb);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	host = get_inode_host(inode);
	idx = reiser4_inode_data(inode)->file_plugin_data.pseudo_info.datum;
	entry = &pentry[idx];
	pset = reiser4_inode_data(host)->pset;

	plug = lookup_plugin(entry->name, buf);
	if (plug != NULL) {
		result = force_plugin(host, entry->memb, plug);
		if (result == 0) {
			__u64 tograb;

			/*
			 * if plugin was updated successfully, save changes in
			 * the stat-data
			 */
			tograb = inode_file_plugin(host)->estimate.update(host);
			result = reiser4_grab_space(tograb, BA_CAN_COMMIT);
			if (result == 0)
				result = reiser4_update_sd(host);
		}
	} else
		result = RETERR(-ENOENT);
	context_set_commit_async(ctx);
	reiser4_exit_context(ctx);
	return result;
}

/*
 * helper function to implement ->lookup() method of pseudo directory plugin
 * for the file that contains multiple similar children pseudo files.
 *
 * For example, "a/..../plugin/" directory contains files for each plugin
 * associated with the host file "a". Handling of read/write for these file is
 * exactly the same, the only difference being the pset member id for the
 * corresponding plugin. Similarly, "a/..../plugin/foo/" itself contains
 * files that are used to provide user access to the corresponding fields of
 * the "foo" plugin, and all such fields can be handled similarly (see
 * show_plugin_field())
 *
 * To avoid code duplication in such situation, an array is constructed that
 * is used as a map from the name of "child" object to the corresponding
 * "datum". All child objects are handled by the same pseudo plugin, and are
 * differentiated by the datum installed into pseudo file inode.
 */
static int array_lookup_pseudo(struct inode *parent, struct dentry **dentry,
			       plugin_entry * array, pseudo_plugin * pplug)
{
	int result;
	int idx;
	struct inode *pseudo;

	pseudo = ERR_PTR(-ENOENT);
	/* search for the given name in the array */
	for (idx = 0; array[idx].name != NULL; ++idx) {
		if (!strcmp((*dentry)->d_name.name, array[idx].name)) {
			pseudo = add_pseudo(parent, pplug, dentry);
			break;
		}
	}
	if (IS_ERR(pseudo))
		result = PTR_ERR(pseudo);
	else {
		result = 0;
		/* if name was found, set datum in the inode */
		pseudo_set_datum(pseudo, idx);
	}
	return result;
}

/*
 * helper method to implement array for the situation when we have multiple
 * child pseudo files with similar functionality. See comment for
 * array_lookup_pseudo().
 */
static int array_readdir_pseudo(struct file *f, void *dirent, filldir_t filld,
				plugin_entry * array, int size)
{
	loff_t off;
	ino_t ino;

	off = f->f_pos;
	if (off < 0)
		return 0;

	/* for god's sake, why switch(loff_t) requires __cmpdi2? */
	switch ((int)off) {
	case 0:
		ino = f->f_dentry->d_inode->i_ino;
		if (filld(dirent, ".", 1, off, ino, DT_DIR) < 0)
			break;
		++off;
		/* fallthrough */
	case 1:
		ino = parent_ino(f->f_dentry);
		if (filld(dirent, "..", 2, off, ino, DT_DIR) < 0)
			break;
		++off;
		/* fallthrough */
	default:
		/* scan array for the names */
		for (; off < size + 1; ++off) {
			const char *name;

			name = array[off - 2].name;
			if (filld(dirent, name, strlen(name),
				  off, off + (long)f, DT_REG) < 0)
				break;
		}
	}
	f->f_pos = off;
	return 0;
}

/*
 * ->lookup() method for the "a/..../plugin/foo/" directory. It uses array
 * representation of child objects, described in the comment for
 * array_lookup_pseudo().
 */
static int lookup_plugin_field(struct inode *parent, struct dentry **dentry)
{
	return array_lookup_pseudo(parent, dentry, fentry,
				   pseudo_plugin_by_id(PSEUDO_PLUGIN_FIELD_ID));
}

/*
 * read method for "a/..../plugin/foo/field"
 */
static int show_plugin_field(struct seq_file *seq, void *cookie)
{
	struct inode *parent;
	struct inode *host;
	struct file *file;
	struct inode *inode;
	reiser4_plugin *plug;
	plugin_entry *entry;
	int pidx;
	int idx;
	plugin_set *pset;

	file = seq->private;
	inode = file->f_dentry->d_inode;

	parent = get_inode_parent(inode);
	host = get_inode_host(inode);
	pidx = reiser4_inode_data(parent)->file_plugin_data.pseudo_info.datum;
	idx = reiser4_inode_data(inode)->file_plugin_data.pseudo_info.datum;
	entry = &pentry[pidx];
	pset = reiser4_inode_data(host)->pset;
	plug = pset_get(pset, entry->memb);

	if (plug != NULL) {
		switch (idx) {
		case PFIELD_TYPEID:
			seq_printf(seq, "%i", plug->h.type_id);
			break;
		case PFIELD_ID:
			seq_printf(seq, "%i", plug->h.id);
			break;
		case PFIELD_LABEL:
			seq_printf(seq, "%s", plug->h.label);
			break;
		case PFIELD_DESC:
			seq_printf(seq, "%s", plug->h.desc);
			break;
		}
	}

	return 0;
}

/*
 * ->readdir() method for "a/..../plugin/foo/". It uses array representation of
 * child objects, described in the comment for array_lookup_pseudo().
 */
static int readdir_plugin_field(struct file *f, void *dirent, filldir_t filld)
{
	return array_readdir_pseudo(f, dirent, filld,
				    fentry, sizeof_array(fentry));
}

/*
 * ->lookup() method for the "a/..../plugin/" directory. It uses array
 * representation of child objects, described in the comment for
 * array_lookup_pseudo().
 */
static int lookup_plugins(struct inode *parent, struct dentry **dentry)
{
	return array_lookup_pseudo(parent, dentry, pentry,
				   pseudo_plugin_by_id(PSEUDO_PLUGIN_ID));
}

/*
 * ->readdir() method for "a/..../plugin/". It uses array representation of
 * child objects, described in the comment for array_lookup_pseudo().
 */
static int readdir_plugins(struct file *f, void *dirent, filldir_t filld)
{
	return array_readdir_pseudo(f, dirent, filld,
				    pentry, sizeof_array(pentry));
}

/*
 * seq-methods for the "a/..../items"
 */

/*
 * start iteration over a sequence of items for the host file. This iterator
 * uses the same cursor as a readdir iterator above.
 */
static void *items_start(struct seq_file *m, loff_t * pos)
{
	struct inode *host;
	readdir_cookie *c;
	file_plugin *fplug;
	reiser4_key headkey;
	int result;
	loff_t entryno;

	/*
	 * first, find first item in the file, then, scan to the *pos-th one.
	 */

	host = get_seq_pseudo_host(m);
	fplug = inode_file_plugin(host);

	down(&host->i_sem);
	if (fplug->key_by_inode == NULL) {
		finish(NULL);
		return NULL;
	}

	/* construct a key of the first item */
	fplug->key_by_inode(host, 0, &headkey);

	c = kmalloc(sizeof *c, GFP_KERNEL);
	if (c == NULL) {
		finish(NULL);
		return ERR_PTR(RETERR(-ENOMEM));
	}

	/* find first item */
	result = object_lookup(host,
			       &headkey,
			       &c->coord,
			       &c->lh,
			       ZNODE_READ_LOCK,
			       FIND_MAX_NOT_MORE_THAN,
			       TWIG_LEVEL, LEAF_LEVEL, 0, NULL);

	tap_init(&c->tap, &c->coord, &c->lh, ZNODE_READ_LOCK);
	if (result == 0)
		result = tap_load(&c->tap); {
		if (result == 0) {
			/*
			 * skip @pos items
			 */
			for (entryno = 0; entryno != *pos; ++entryno) {
				result = go_next_unit(&c->tap);
				if (result == -E_NO_NEIGHBOR) {
					finish(c);
					return NULL;
				}
				if (result != 0)
					break;
				if (!fplug->owns_item(host, c->tap.coord)) {
					finish(c);
					return NULL;
				}
			}
		}
		}
		if (result != 0) {
			finish(c);
			return ERR_PTR(result);
		} else
			return c;
}

/*
 * stop iteration over a sequence of items for the host file
 */
static void items_stop(struct seq_file *m, void *v)
{
	up(&get_seq_pseudo_host(m)->i_sem);
	finish(v);
}

/* go to the next item in the host file */
static void *items_next(struct seq_file *m, void *v, loff_t * pos)
{
	readdir_cookie *c;
	struct inode *host;
	int result;

	c = v;
	++(*pos);
	host = get_seq_pseudo_host(m);
	result = go_next_unit(&c->tap);
	if (result == 0) {
		if (!inode_file_plugin(host)->owns_item(host, c->tap.coord)) {
			finish(c);
			return NULL;
		} else
			return v;
	} else {
		finish(c);
		return ERR_PTR(result);
	}
}

/* output information about single item of the host file */
static int items_show(struct seq_file *m, void *v)
{
	readdir_cookie *c;
	item_plugin *iplug;
	char buf[KEY_BUF_LEN];
	reiser4_key key;

	c = v;
	iplug = item_plugin_by_coord(&c->coord);

	/* output key... */
	sprintf_key(buf, unit_key_by_coord(&c->coord, &key));
	/* ... and item plugin label... */
	seq_printf(m, "%s %s\n", buf, iplug->h.label);
	return 0;
}

int create_vfs_object(struct inode *, struct dentry *,
		      reiser4_object_create_data *);

/*
 * write method for the "a/..../new" file. Extract file name from the user
 * supplied buffer @buf, and create regular file with that name within host
 * file (that is better to be a directory).
 */
static int get_new(struct file *file, const char *buf)
{
	int result;

	/* check that @buf contains no slashes */
	if (strchr(buf, '/') == NULL) {
		struct dentry *d;
		struct qstr name;
		unsigned int c;
		unsigned long hash;

		reiser4_object_create_data data;
		memset(&data, 0, sizeof data);

		data.mode = S_IFREG | 0 /* mode */ ;
		data.id = UNIX_FILE_PLUGIN_ID;

		name.name = buf;
		c = *(const unsigned char *)buf;

		/* build hash of the name */
		hash = init_name_hash();
		do {
			buf++;
			hash = partial_name_hash(c, hash);
			c = *(const unsigned char *)buf;
		} while (c);
		name.len = buf - (const char *)name.name;
		name.hash = end_name_hash(hash);

		/* allocate dentry */
		d = d_alloc(file->f_dentry->d_parent->d_parent, &name);
		if (d == NULL)
			result = RETERR(-ENOMEM);
		else {
			/* call ->create() method of the host directory */
			result =
			    create_vfs_object(get_pseudo_host(file), d, &data);
			reiser4_free_dentry_fsdata(d);
		}
	} else
		result = RETERR(-EINVAL);
	return result;
}

/*
 * initialize pseudo plugins.
 */
pseudo_plugin pseudo_plugins[LAST_PSEUDO_ID] = {
	[PSEUDO_METAS_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_METAS_ID,
			.pops = NULL,
			.label = "....",
			.desc = "meta-files",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = TOP_LEVEL,
		.try = try_by_label,
		.readdirable = 0,
		.lookup = lookup_table,
		.lookup_mode = S_IFDIR | S_IRUGO | S_IXUGO,
		.read_type = PSEUDO_READ_NONE,
		.write_type = PSEUDO_WRITE_NONE,
		.readdir = readdir_table
	},
	[PSEUDO_UID_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_UID_ID,
			.pops = NULL,
			.label = "uid",
			.desc = "returns owner",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_uid
		},
		.write_type = PSEUDO_WRITE_STRING,
		.write = {
			.gets = store_uid
		}
	},
	[PSEUDO_GID_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_GID_ID,
			.pops = NULL,
			.label = "gid",
			.desc = "returns group",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_gid
		},
		.write_type = PSEUDO_WRITE_STRING,
		.write = {
			.gets = get_gid
		}
	},
	[PSEUDO_RWX_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_RWX_ID,
			.pops = NULL,
			.label = "rwx",
			.desc = "returns rwx permissions",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO | S_IWUSR,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_rwx
		},
		.write_type = PSEUDO_WRITE_STRING,
		.write = {
			.gets = get_rwx
		}
	},
	[PSEUDO_OID_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_OID_ID,
			.pops = NULL,
			.label = "oid",
			.desc = "returns object id",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_oid
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_KEY_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_KEY_ID,
			.pops = NULL,
			.label = "key",
			.desc = "returns object's key",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO}
		,
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_key
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_SIZE_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_SIZE_ID,
			.pops = NULL,
			.label = "size",
			.desc = "returns object's size",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_size
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_NLINK_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_NLINK_ID,
			.pops = NULL,
			.label = "nlink",
			.desc = "returns nlink count",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_nlink
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_LOCALITY_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_LOCALITY_ID,
			.pops = NULL,
			.label = "locality",
			.desc = "returns object's locality",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_locality
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_PSEUDOS_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_PSEUDOS_ID,
			.pops = NULL,
			.label = "pseudo",
			.desc = "returns a list of pseudo files",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SEQ,
		.read = {
			.ops = {
				.start = pseudos_start,
				.stop = pseudos_stop,
				.next = pseudos_next,
				.show = pseudos_show
			}
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_BMAP_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_BMAP_ID,
			.pops = NULL,
			.label = "bmap",
			.desc = "returns a list blocks for this file",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SEQ,
		.read = {
			.ops = {
				.start = bmap_start,
				.stop = bmap_stop,
				.next = bmap_next,
				.show = bmap_show
			}
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_READDIR_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_READDIR_ID,
			.pops = NULL,
			.label = "readdir",
			.desc =
			"returns a list of names in the dir",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SEQ,
		.read = {
			.ops = {
				.start = readdir_start,
				.stop = readdir_stop,
				.next = readdir_next,
				.show = readdir_show
			}
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_PLUGIN_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_PLUGIN_ID,
			.pops = NULL,
			.label = "plugin",
			.desc = "plugin",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_PLUGINS_ID,
		.try = NULL,
		.readdirable = 0,
		.lookup = lookup_plugin_field,
		/*
		 * foo/..../plugin/bar is much like a directory. So, why
		 * there is no S_IFDIR term in the .lookup_mode, you ask?
		 *
		 * fs/namei.c:may_open():
		 *
		 *     if (S_ISDIR(inode->i_mode) && (flag & FMODE_WRITE))
		 *         return -EISDIR;
		 *
		 * Directory cannot be opened for write. How smart.
		 */
		.lookup_mode =
		S_IFREG | S_IRUGO | S_IWUSR | S_IXUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_plugin
		},
		.write_type = PSEUDO_WRITE_STRING,
		.write = {
			.gets = set_plugin
		},
		.readdir = readdir_plugin_field
	},
	[PSEUDO_PLUGINS_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_PLUGINS_ID,
			.pops = NULL,
			.label = "plugin",
			.desc = "list of plugins",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = lookup_plugins,
		.lookup_mode = S_IFDIR | S_IRUGO | S_IXUGO,
		.read_type = PSEUDO_READ_NONE,
		.write_type = PSEUDO_WRITE_NONE,
		.readdir = readdir_plugins
	},
	[PSEUDO_PLUGIN_FIELD_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_PLUGIN_ID,
			.pops = NULL,
			.label = "plugin-field",
			.desc = "plugin field",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_PLUGIN_ID,
		.try = NULL,
		.readdirable = 0,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SINGLE,
		.read = {
			.single_show = show_plugin_field
		},
		.write_type = PSEUDO_WRITE_NONE,
		.readdir = NULL
	},
	[PSEUDO_ITEMS_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_ITEMS_ID,
			.pops = NULL,
			.label = "items",
			.desc =
			"returns a list of items for this file",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IRUGO,
		.read_type = PSEUDO_READ_SEQ,
		.read = {
			.ops = {
				.start = items_start,
				.stop = items_stop,
				.next = items_next,
				.show = items_show
			}
		},
		.write_type = PSEUDO_WRITE_NONE
	},
	[PSEUDO_NEW_ID] = {
		.h = {
			.type_id = REISER4_PSEUDO_PLUGIN_TYPE,
			.id = PSEUDO_NEW_ID,
			.pops = NULL,
			.label = "new",
			.desc = "creates new file in the host",
			.linkage = TYPE_SAFE_LIST_LINK_ZERO
		},
		.parent = PSEUDO_METAS_ID,
		.try = try_by_label,
		.readdirable = 1,
		.lookup = NULL,
		.lookup_mode = S_IFREG | S_IWUSR,
		.read_type = PSEUDO_READ_NONE,
		.read = {
			.single_show = show_rwx
		},
		.write_type = PSEUDO_WRITE_STRING,
		.write = {
			.gets = get_new
		}
	}
};

/* Make Linus happy.
   Local variables:
   c-indentation-style: "K&R"
   mode-name: "LC"
   c-basic-offset: 8
   tab-width: 8
   fill-column: 120
   scroll-step: 1
   End:
*/
