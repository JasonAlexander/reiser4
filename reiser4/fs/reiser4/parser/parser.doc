Interpolate file (IF)

In my opinion the procedure of creation IF is closely connected to the
language of reiser4 system call. 

in reiser4 system call we are using assign operator:

object_a<-object_b+object_c....

reiser4 system call works as follows:
 During parsing of the right-hand side of the assignment statement
 (reiser4 system call) the sequence of links to objects of a file
 system should be constructed.  Links are resolved to the expressions
 of the type 'body of the file' during assignment and result is
 assigned to the left-hand objects.


and
This is Hans's example from interpolate.c 


target_filename/symlink<=
`@freshly_interpolate_this_filename_whenever_resolving_target_filename
+`here is some text stored directly in the symlink''
+@interpolate_this_filename_at_symlink_creation_time
+`@freshly_interpolate_this_filename2_whenever_resolving_target_filename
+"this is some more text that is directly embedded in the symlink"'

In this expression we have 3 type objects:
1 freshly_interpolate_this_filename_whenever_resolving_target_filename(type1)
2 here is some text stored directly in the symlink(type2)
3 interpolate_this_filename_at_symlink_creation_time(type3)

I propose use another symbol for symlink operator: "->"

target_object_name->object_type1+object_type2+object_type3....

where :

type2 can converted from this text to the new regular file with a
unique name (for example, serial number), and create link on it.

for type3 we need make a copy of contens of that object in new regular
file with unique name for it (for example, serial number), and create
link to it.

In this case we will have only links to objects(extents). 

symlink operation (->) just converting links from internal to
external format rather than resolving them in assign operator.

Reading of this file (i.e. obtaining of value such as 'a body of the
file ') is reduced to reading links and them resolve by same
algorithm, as well as during assignment.

The file constructed thus basically is similar to a traditional
directory, except for the following moments.

1. Extended link to a part of the file.
2. extended read  method.
3. extended write method.

If we will decide to create the IF as the directory, then, along with
reiser4() syntax, standard directory access commands can be used.

Is this case we can make for objects type 2 and 3 standard directory
entries and only for object type 1 - symlink.

Then, any directory can be interpreted as the IF file after
replacement of a method of reading and writing, and, moreover, each
element of the directory is also accessible through standard means.

Problems of recursion and cycles are, in this case, solved by normal
file system control mechanisms.

Independently of whether IFs will be implemented as directories, there
are certain problems with editing of the content of the whole IF.

symlink to a part of the file, in addition to the normal symlink has following extensions:

1. unit of measure (byte, line, substring....).
2. type of an extent (fixed, extended, obvious border????)
3. offset, measured in symlink's unit (the beginning of an extent)
4. length of an extent in symlink's unit (the end of an extent).


EOEXT

a state of the end of an extent.  Arises at reading when there was a
command of reading on the indicated extent with offset bigger than
extent's length.  Similarly at writing: writing with offset bigger
than extent's length. At reading and writing it is necessary to make
a control for each level of an enclosure on the end of an extent in
indicated for it units.


Read

we open the file indicated in link by reading.  We are taken up a
position on the indicated offset to the beginning of an extent.
Further we read and it is checked up on EOEXT.  If the file indicated
in link is IF the procedure of reading works recursively, with
possibly different units and offsets.  close file.

write:

 variants (are specified in options) are possible(probable):

a. The fixed extent, units is byte:

  after of write to an extent the length of an extent does not
  change.
  If the extent in which it is necessary to write, is defined
  recursively, those consists of extents, write is made in turn in
  process of change of offset:
  on Write in each extent we check up on EOEXT.  If EOEXT, then we
  jump next extent.  

  append in this extent is not possible.


b. An extended extent: 

 open the target file as rw :
 seek to a position on, corresponding end of extent.  The tail (that
 is after our extent in the original file) cut (is copied and thrown
 in close a method),if it not empty. seek to position, corresponding
 to the beginning of an extent and truncate in this point.  Further
 write in the file and check it on EOEXT.  At closing we add a tail.

  In case of a recursive extent, a main problem is jump to the
  next extent.

Append to file - the variety of recording in the end: 
  we are taken up a position on the end of an extent, a tail also
  cut and is farther as at simple recording.


b.1. write in depending of a context. diff format method.

  write is made in temporary area as in the regular file.  
  At closing make diff two files: initial and result of new recording.
  
  this will hapen also in make_new_and_rename_to_old. in rename
  function if target is IF we make diff.


All hunks in diff are separate into extents. 

 If any hunk concerns at once several extents unambiguous solution of
 splitting hunk does not exist.  Additional algorithms in this case
 are necessary for their implementation.

 For example, hunk substitutes lines from the first on the third
 extent inclusively, on same quantity of lines.  It means, that
 contents of this three extents are erased. But how to arrange the
 new text between extents?

Additional methods are necessary for the decision of this
problem, for example a method of borders. Or anyone another,
allowing unequivocally to determine changes, concerning an extent.

  At successful spliting of hunks on extents we transfer them for plugin
  the appropriate file with conversion offset in current unit to ofset of
  file. Where it is similar way hunks are divided on extents if this
  file also is IF.  Or, if the file is regular, we make purely
  changes.

b.2. write in depending of a context. border method.

  for this mode reading with separators is necessary to provide the
  beginning of an extent and the end.

  In begin (in header) the complete information about extent in the
  same format as it was created is output:

..interpolate_header  name
..type =symlink_extended_with_border
/path/file/..order/offset/last_byte
new_body
..interpolate_end name

  As a result of editing these borders mast be constant and if
  changed, so that unambiguously to determine the linked object.  At
  recording the structure IF will be created as new on the basis of
  headers by way of their layout.  As against create where created
  only links to file extents, substitution of old value of a site with
  new value here is made In this case recording is reduced to creation
  of the file.



Special case of the fixed extent, but representing I think the
greatest interest it when a unit of measure - line, In this case
the extent works as boundaries method, but without creation of
header,


